# HIST-2025-006: Implementar Driver Matching com PostGIS

**Data**: 03/01/2026  
**Status**: ✅ DONE  
**Tipo**: Feature

## Descrição

Implementar o algoritmo de **matching geoespacial** que conecta passageiros a motoristas disponíveis baseado em proximidade geográfica usando queries PostGIS. Esta é uma funcionalidade **core** de qualquer plataforma ride-hailing.

## Objetivos

1. ✅ **Driver Matching Algorithm**: Encontrar motoristas disponíveis próximos ao pickup location
2. ✅ **Geospatial Queries**: Usar PostGIS para busca por raio/distância
3. ✅ **Output Port**: `DriverGeoQueryPort` para queries geoespaciais
4. ✅ **Use Case**: `FindAvailableDriversUseCase`
5. ✅ **Infrastructure Adapter**: Implementar queries PostGIS no `JpaDriverRepositoryAdapter`
6. ✅ **REST Endpoint**: `GET /api/v1/drivers/nearby`
7. ✅ **Testes Unitários**: Validar matching com diferentes cenários
8. ✅ **Arquitetura Hexagonal**: Manter princípios SOLID e separação de camadas

## Critérios de Aceitação

- ✅ Buscar motoristas num raio configurável (padrão: 5km, máximo: 50km)
- ✅ Motoristas devem estar ACTIVE + ter localização + CNH válida
- ✅ Retornar lista ordenada por distância (mais próximo primeiro)
- ✅ Considerar tenant isolation (multi-tenancy)
- ✅ Performance: Query geoespacial otimizada com índice GIST
- ✅ Validações: raio entre 0-50km, parâmetros obrigatórios

## Estrutura de Pacotes

```
src/main/java/com/rappidrive/
├── application/
│   ├── ports/
│   │   ├── input/
│   │   │   └── driver/
│   │   │       ├── FindAvailableDriversCommand.java      ✅ NEW
│   │   │       └── FindAvailableDriversInputPort.java    ✅ NEW
│   │   └── output/
│   │       └── DriverGeoQueryPort.java                   ✅ NEW
│   └── usecases/
│       └── driver/
│           └── FindAvailableDriversUseCase.java          ✅ NEW
├── infrastructure/
│   ├── persistence/
│   │   ├── adapters/
│   │   │   └── JpaDriverRepositoryAdapter.java           ✅ MODIFIED
│   │   └── repositories/
│   │       └── SpringDataDriverRepository.java           ✅ MODIFIED
│   └── config/
│       └── UseCaseConfiguration.java                     ✅ MODIFIED
└── presentation/
    ├── controllers/
    │   └── DriverController.java                         ✅ MODIFIED
    └── mappers/
        └── DriverDtoMapper.java                          ✅ MODIFIED

src/test/java/com/rappidrive/
├── application/
│   └── usecases/
│       └── driver/
│           └── FindAvailableDriversUseCaseTest.java      ✅ NEW
└── architecture/
    └── HexagonalArchitectureTest.java                    ✅ MODIFIED
```

## Output Port (DriverGeoQueryPort)

**Interface**: `application/ports/output/DriverGeoQueryPort.java`

```java
public interface DriverGeoQueryPort {
    /**
     * Finds available drivers near a specific location.
     * Uses PostGIS spatial queries to search within a radius.
     * Results are ordered by distance (nearest first).
     */
    List<Driver> findAvailableDriversNearby(
        Location pickupLocation, 
        double radiusKm, 
        TenantId tenantId
    );
}
```

**Responsabilidade**: Definir contrato para queries geoespaciais (driven port).

## Input Port & Command

**Command**: `application/ports/input/driver/FindAvailableDriversCommand.java`

```java
public record FindAvailableDriversCommand(
    TenantId tenantId,
    Location pickupLocation,
    double radiusKm
) {
    // Validações no compact constructor:
    // - tenantId não-nulo
    // - pickupLocation não-nulo
    // - radiusKm entre 0 e 50km
    
    // Constructor padrão com radius 5km
    public FindAvailableDriversCommand(TenantId tenantId, Location pickupLocation) {
        this(tenantId, pickupLocation, 5.0);
    }
}
```

**Input Port**: `application/ports/input/driver/FindAvailableDriversInputPort.java`

```java
public interface FindAvailableDriversInputPort {
    List<Driver> execute(FindAvailableDriversCommand command);
}
```

## Use Case (FindAvailableDriversUseCase)

**Localização**: `application/usecases/driver/FindAvailableDriversUseCase.java`

**Lógica**:
```java
@RequiredArgsConstructor
public class FindAvailableDriversUseCase implements FindAvailableDriversInputPort {
    
    private final DriverGeoQueryPort driverGeoQueryPort;
    
    @Override
    public List<Driver> execute(FindAvailableDriversCommand command) {
        // 1. Query geoespacial (delega para infrastructure)
        List<Driver> driversNearby = driverGeoQueryPort.findAvailableDriversNearby(
            command.pickupLocation(),
            command.radiusKm(),
            command.tenantId()
        );
        
        // 2. Filtro de domínio (business rule)
        return driversNearby.stream()
            .filter(Driver::isAvailableForRide)  // ACTIVE + location + CNH válida
            .toList();
    }
}
```

**Responsabilidades**:
- Orquestrar busca geoespacial via porta de saída
- Aplicar regras de negócio do domínio (`isAvailableForRide()`)
- Retornar lista filtrada e ordenada

## Infrastructure - PostGIS Queries

**Adapter**: `infrastructure/persistence/adapters/JpaDriverRepositoryAdapter.java`

Implementa **duas interfaces**:
- `DriverRepositoryPort` (CRUD)
- `DriverGeoQueryPort` (geospatial) ✅ NEW

```java
@Component
@RequiredArgsConstructor
public class JpaDriverRepositoryAdapter implements DriverRepositoryPort, DriverGeoQueryPort {
    
    private final SpringDataDriverRepository jpaRepository;
    private final DriverMapper mapper;
    
    // ... métodos CRUD ...
    
    @Override
    public List<Driver> findAvailableDriversNearby(Location pickupLocation, double radiusKm, TenantId tenantId) {
        return jpaRepository.findDriversWithinRadius(
                pickupLocation.getLatitude(),
                pickupLocation.getLongitude(),
                radiusKm * 1000, // km → meters
                tenantId
            )
            .stream()
            .map(mapper::toDomain)
            .toList();
    }
}
```

**Repository**: `infrastructure/persistence/repositories/SpringDataDriverRepository.java`

**Query PostGIS** (Native SQL):

```sql
SELECT d.*
FROM drivers d
WHERE d.tenant_id = :tenantId
  AND d.location_latitude IS NOT NULL
  AND d.location_longitude IS NOT NULL
  AND ST_DWithin(
      ST_SetSRID(ST_MakePoint(d.location_longitude, d.location_latitude), 4326)::geography,
      ST_SetSRID(ST_MakePoint(:longitude, :latitude), 4326)::geography,
      :radiusMeters
  )
ORDER BY ST_Distance(
  ST_SetSRID(ST_MakePoint(d.location_longitude, d.location_latitude), 4326)::geography,
  ST_SetSRID(ST_MakePoint(:longitude, :latitude), 4326)::geography
)
```

**Explicação PostGIS**:
- `ST_DWithin`: Busca otimizada dentro de raio (usa índice GIST)
- `ST_Distance`: Ordena por distância (nearest first)
- `geography` type: Cálculo preciso em esfera (considerando curvatura da Terra)
- SRID 4326: WGS 84 (padrão GPS)
- Índice GIST já existente: `idx_drivers_location` (migration V2)

## Presentation Layer - REST API

**Endpoint**: `GET /api/v1/drivers/nearby`

**Query Parameters**:
- `tenantId` (UUID, required): Tenant identifier
- `latitude` (double, required): Pickup latitude
- `longitude` (double, required): Pickup longitude  
- `radiusKm` (double, optional): Search radius (default: 5.0, max: 50.0)

**Response**: Lista de `DriverResponse` ordenada por distância

**Exemplo**:
```bash
GET /api/v1/drivers/nearby?tenantId=123e4567-e89b-12d3-a456-426614174000&latitude=-23.550520&longitude=-46.633308&radiusKm=10

[
  {
    "id": "uuid1",
    "fullName": "João Silva",
    "status": "ACTIVE",
    "currentLocation": { "latitude": -23.551000, "longitude": -46.634000 },
    ...
  },
  {
    "id": "uuid2",
    "fullName": "Maria Santos",
    "status": "ACTIVE",
    "currentLocation": { "latitude": -23.552500, "longitude": -46.635200 },
    ...
  }
]
```

**Controller**: `presentation/controllers/DriverController.java`

```java
@GetMapping("/nearby")
public ResponseEntity<?> findNearbyDrivers(
        @RequestParam UUID tenantId,
        @RequestParam double latitude,
        @RequestParam double longitude,
        @RequestParam(defaultValue = "5.0") double radiusKm) {
    
    FindAvailableDriversCommand command = new FindAvailableDriversCommand(
        mapper.toTenantId(tenantId),
        mapper.toLocation(latitude, longitude),
        radiusKm
    );
    
    var drivers = findAvailableDriversUseCase.execute(command);
    var responses = drivers.stream()
        .map(mapper::toResponse)
        .toList();
    
    return ResponseEntity.ok(responses);
}
```

## Testes

### Testes Unitários (FindAvailableDriversUseCaseTest)

**Total**: 8 cenários

1. ✅ **shouldFindAvailableDriversWithinRadius**: Retorna apenas motoristas ACTIVE com localização e CNH válida
2. ✅ **shouldFilterOutInactiveDrivers**: Filtra motoristas INACTIVE
3. ✅ **shouldFilterOutDriversWithoutLocation**: Filtra motoristas sem localização
4. ✅ **shouldFilterOutDriversWithExpiredCNH**: Filtra motoristas com CNH expirada
5. ✅ **shouldReturnEmptyListWhenNoDriversNearby**: Retorna lista vazia quando nenhum motorista próximo
6. ✅ **shouldUseCustomRadius**: Valida uso de raio customizado
7. ✅ **shouldValidateCommandParameters**: Valida parâmetros do comando (null, raio inválido)
8. ✅ **shouldUseDefaultRadiusWhenNotProvided**: Valida raio padrão de 5km

**Tecnologias**:
- JUnit 5
- Mockito (mock de `DriverGeoQueryPort`)
- AssertJ

### Testes de Arquitetura (HexagonalArchitectureTest)

**Modificações**:
1. ✅ Atualizado `portsShouldBeInterfaces`: Exclui `Record` classes (Commands)
2. ✅ Atualizado `useCasesShouldImplementInputPorts`: Adiciona `FindAvailableDriversInputPort`

**Total de regras**: 11 (todas passando)

## Configuração

**Bean Wiring**: `infrastructure/config/UseCaseConfiguration.java`

```java
@Bean
public FindAvailableDriversInputPort findAvailableDriversUseCase(DriverGeoQueryPort driverGeoQueryPort) {
    return new FindAvailableDriversUseCase(driverGeoQueryPort);
}
```

**Injeção de Dependência**:
- `FindAvailableDriversUseCase` → `DriverGeoQueryPort`
- `DriverController` → `FindAvailableDriversInputPort`

## Decisões de Arquitetura

### ADR-001: PostGIS para Queries Geoespaciais

**Contexto**: Necessidade de buscar motoristas próximos com performance.

**Decisão**: Usar PostGIS (extensão PostgreSQL) com índice GIST.

**Alternativas Rejeitadas**:
- Cálculo Haversine em memória (lento, não escalável)
- MongoDB GeoJSON (mudança de banco)
- Elasticsearch (overhead para MVP)

**Consequências**:
- ✅ Performance: Índice GIST otimiza busca espacial
- ✅ Precisão: `geography` type considera curvatura da Terra
- ✅ Escalabilidade: Query eficiente mesmo com milhares de motoristas
- ⚠️ Vendor lock-in: Dependência do PostgreSQL/PostGIS

### ADR-002: Filtro de Domínio no Use Case

**Contexto**: Onde aplicar regra `isAvailableForRide()`?

**Decisão**: Filtro no use case após query geoespacial.

**Alternativas Rejeitadas**:
- Query SQL complexa (viola separação domain/infrastructure)
- Filtro no controller (viola separação presentation/application)

**Consequências**:
- ✅ Regras de negócio centralizadas no domínio
- ✅ Fácil testar com mocks
- ⚠️ Leve overhead: traz mais dados do banco e filtra depois

### ADR-003: Command como Record

**Contexto**: Como estruturar comandos de input ports?

**Decisão**: Usar Java `record` com validações no compact constructor.

**Alternativas Rejeitadas**:
- POJOs com setters (viola imutabilidade)
- Builder pattern (overhead desnecessário)

**Consequências**:
- ✅ Imutabilidade garantida
- ✅ Validações centralizadas
- ✅ Código conciso
- ⚠️ Atualização de teste de arquitetura (excluir records da regra de interfaces)

## Dependências Externas

- **PostGIS**: Extensão já habilitada (migration V1)
- **Índice GIST**: Já criado em `drivers.location` (migration V2)
- **Nenhuma nova dependência Maven/Gradle**

## Performance

**Estimativas** (baseado em índice GIST):

| Cenário | Motoristas no DB | Tempo de Query | Observação |
|---------|------------------|----------------|------------|
| 100 drivers | 100 | ~5ms | Sem índice: ~50ms |
| 1,000 drivers | 1,000 | ~10ms | Sem índice: ~500ms |
| 10,000 drivers | 10,000 | ~20ms | Sem índice: ~5s |
| 100,000 drivers | 100,000 | ~50ms | Índice GIST crítico |

**Otimizações futuras** (se necessário):
- Cache de motoristas disponíveis (Redis)
- Clustering espacial (QuadTree)
- Read replicas para queries read-heavy

## Resultados Finais

### Testes

```
[INFO] Tests run: 248, Failures: 0, Errors: 0, Skipped: 0
[INFO] BUILD SUCCESS
```

**Distribuição**:
- Architecture: 11 tests (regras hexagonais)
- DriverTest: 32 tests (incluindo regras CNH)
- PassengerTest: 22 tests
- TripTest: 31 tests
- Value Objects: 145 tests
- **FindAvailableDriversUseCaseTest**: 8 tests ✅ NEW

**Aumento**: +8 testes (de 240 → 248)

### Cobertura de Código

**Cobertura estimada**:
- Use Case: 100% (todos os branches testados)
- Command: 100% (validações testadas)
- Input Port: 100% (interface)
- Output Port: Não aplicável (integração com DB)

### Funcionalidades Entregues

1. ✅ **Geospatial Search**: PostGIS queries otimizadas
2. ✅ **Driver Filtering**: Aplicação de regras de negócio
3. ✅ **REST API**: Endpoint `/nearby` documentado
4. ✅ **Tenant Isolation**: Multi-tenancy respeitado
5. ✅ **Validation**: Raio, coordenadas, parâmetros obrigatórios
6. ✅ **Testing**: 8 testes unitários cobrindo todos os cenários
7. ✅ **Architecture**: Hexagonal principles mantidos

## Próximos Passos

Para evoluir a funcionalidade de matching:

1. **HIST-2025-007**: Implementar algoritmo de atribuição automática (auto-dispatch)
   - Lógica: Buscar motoristas disponíveis e atribuir ao mais próximo
   - Use case: `AutoAssignDriverToTripUseCase`
   - Event-driven: Emitir evento quando trip é criada

2. **HIST-2025-008**: Adicionar filtros avançados de matching
   - Categoria de veículo (sedan, SUV, van)
   - Rating mínimo do motorista
   - Preferências do passageiro

3. **HIST-2025-009**: Implementar cache de motoristas disponíveis
   - Redis para latência <10ms
   - Atualização em tempo real via WebSocket

4. **HIST-2025-010**: Adicionar métricas de performance
   - Tempo médio de matching
   - Taxa de sucesso de atribuição
   - Monitoramento com Micrometer/Prometheus

## Referências

- [PostGIS Documentation](https://postgis.net/docs/ST_DWithin.html)
- [PostgreSQL Geography Type](https://postgis.net/docs/geography.html)
- [Haversine Formula](https://en.wikipedia.org/wiki/Haversine_formula)
- [Hexagonal Architecture - Alistair Cockburn](https://alistair.cockburn.us/hexagonal-architecture/)
- [Clean Architecture - Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

---

**Assinatura**: Sistema RappiDrive Backend - Hexagonal Architecture  
**Revisão**: ✅ Arquitetura validada, 248 testes passando  
**Data de Conclusão**: 03/01/2026
