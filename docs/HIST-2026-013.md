# HIST-2026-013: SLO de Atribui√ß√£o de Motoristas & Auto-Remedia√ß√£o

**Data**: 10/01/2026  
**Status**: üü° Planejado  
**Tipo**: Observabilidade / Confiabilidade  
**Tamanho**: M√©dio (3-4 dias)

## Contexto
Agora que tracing, m√©tricas e logs estruturados foram introduzidos, ainda n√£o existe visibilidade ponta a ponta sobre o fluxo cr√≠tico de **atribui√ß√£o de motoristas** (buscar, selecionar, notificar). A aus√™ncia de SLO definido e alertas impede detectar degrada√ß√µes, e corridas podem permanecer indefinidamente no estado `ASSIGNING`, degradando a taxa de convers√£o.

## Objetivo
1. Definir e monitorar um SLO (p90 ‚â§ 5s) para o tempo de atribui√ß√£o de motoristas.
2. Instrumentar cada etapa do fluxo com m√©tricas e spans de dom√≠nio.
3. Configurar alertas Prometheus + dashboard para detectar viola√ß√µes e tempestades de retries.
4. Implementar auto-remedia√ß√£o para trips presas e publicar eventos rastre√°veis.

## Crit√©rios de Aceite

### 1. Telemetria do Fluxo de Assignment
- `FindAvailableDriversUseCase`, `AssignDriverToTripUseCase` e `SendNotificationUseCase` usam `TelemetryPort` com spans nomeados (`driver.search`, `driver.assignment`, `driver.notify`).
- M√©tricas Prometheus:
  - `driver_assignment_duration_seconds` (Histogram, label `stage`).
  - `driver_assignment_attempts_total` (Counter, labels `stage`, `status` ‚àà {success,error,retry}).
  - `driver_assignment_queue_size` (Gauge) refletindo trips aguardando atribui√ß√£o.
- Todos os spans adicionam tags `tripId`, `tenantId`, `stage` para correla√ß√£o.

### 2. Alertas & Dashboard
- Atualizar `docker/prometheus/prometheus.yml` para carregar novo arquivo de regras `rules-driver-assignment.yml`.
- Regras m√≠nimas:
  - **SLO Breach**: p90(`driver_assignment_duration_seconds{stage="assignment"}`) > 5s por 5m.
  - **Retry Storm**: soma de `driver_assignment_attempts_total{status="retry"}` > 10 por minuto.
  - **Queue Stuck**: `driver_assignment_queue_size` > 20 por 10m.
- Adicionar documenta√ß√£o (README ou `docs/`) com instru√ß√µes para importar dashboard Grafana (JSON fornecido) e interpretar alertas.

### 3. Auto-remedia√ß√£o para Trips Presas
- Novo use case `AutoRemediateStuckTripUseCase` que:
  - Identifica trips com status `ASSIGNING` por mais de `assignment.auto-remediation.threshold-minutes`.
  - Cancela tentativa atual, reabre busca ou marca para reprocessamento e notifica passageiro.
  - Publica `TripAssignmentStuckEvent` via Outbox.
- Scheduler (`@Scheduled`) em infrastructure executa o use case e registra `auto_remediation_runs_total` e `auto_remediation_actions_total` (labels `action`).

### 4. Testes & Documenta√ß√£o
- Testes unit√°rios cobrindo telemetria nos use cases (verificando chamadas ao `TelemetryPort`).
- Testes de integra√ß√£o confirmando exposi√ß√£o das m√©tricas em `/actuator/prometheus`.
- Testes do novo use case/scheduler garantindo multi-tenancy e publica√ß√£o do evento.
- README atualizado com: como subir Zipkin/Prometheus, dashboard, alertas e runbook de resposta (incluindo auto-remedia√ß√£o manual se necess√°rio).

## Entreg√°veis
- Implementa√ß√£o de m√©tricas/tracing nos use cases citados.
- Arquivos Prometheus atualizados (`prometheus.yml` + `rules-driver-assignment.yml`) e dashboard JSON.
- Novo use case + scheduler + evento `TripAssignmentStuckEvent`.
- Testes automatizados e documenta√ß√£o do runbook.

## Notas T√©cnicas
- Continuar usando `TelemetryPort` para manter isolamento do dom√≠nio em rela√ß√£o ao Micrometer.
- M√©tricas devem ser registradas uma √∫nica vez por bean (evitar recria√ß√£o de `Gauge`).
- Scheduler deve usar virtual threads e operar por tenant (paginando resultados para evitar locks longos).
- Alertas precisam de labels `environment`/`tenant` quando poss√≠vel para facilitar silenciamento segmentado.
- Auto-remedia√ß√£o deve ser idempotente; manipular transa√ß√µes para evitar corridas com o fluxo normal de assignment.
