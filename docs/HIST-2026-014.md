# HIST-2026-014: IntegraÃ§Ã£o com Keycloak para AutenticaÃ§Ã£o & AutorizaÃ§Ã£o

**Data**: 12/01/2026  
**Status**: ğŸ“‹ Planejado  
**Tipo**: SeguranÃ§a / Infraestrutura  
**Tamanho**: Grande (5-7 dias)  
**Prioridade**: Alta  
**DependÃªncias**: HIST-2026-012 (Admin users)

---

## 1. Contexto & MotivaÃ§Ã£o

### SituaÃ§Ã£o Atual
A aplicaÃ§Ã£o possui autenticaÃ§Ã£o JWT bÃ¡sica (`SecurityConfiguration.java`) com secret hardcoded:
- âœ… JWT validation funcional com Spring Security OAuth2 Resource Server
- âœ… Estrutura RBAC com scopes (`SCOPE_admin`, `SCOPE_driver`, `SCOPE_passenger`)
- âœ… Multi-tenancy enforcement via `TenantId` em todos os agregados
- âŒ **Problema**: GestÃ£o de usuÃ¡rios, senhas e tokens feita manualmente
- âŒ **Problema**: Sem suporte a SSO, MFA, federaÃ§Ã£o de identidade
- âŒ **Problema**: Sem interface administrativa para gestÃ£o de usuÃ¡rios

### Por Que Keycloak?
**Keycloak** Ã© a soluÃ§Ã£o open-source lÃ­der para Identity & Access Management (IAM):
- âœ… **Standards-based**: OpenID Connect, OAuth 2.0, SAML
- âœ… **Multi-tenancy nativo**: Realms isolados por tenant
- âœ… **Enterprise-ready**: SSO, MFA, social login, user federation (LDAP/AD)
- âœ… **Zero-code**: Admin Console UI para gestÃ£o de usuÃ¡rios/roles
- âœ… **Auditing**: Logs completos de login/logout/permissÃµes
- âœ… **IntegraÃ§Ã£o Spring**: Spring Security OAuth2 suporta nativamente

### Alinhamento com Arquitetura Hexagonal
A integraÃ§Ã£o **nÃ£o viola** princÃ­pios hexagonais:
- **Domain Layer**: Permanece 100% framework-free (sem Keycloak SDK)
- **Application Layer**: `CurrentUserPort` jÃ¡ abstrai autenticaÃ§Ã£o
- **Infrastructure Layer**: Adapter Keycloak (`KeycloakAuthenticationAdapter`) implementa a porta
- **Presentation Layer**: Controllers continuam usando `@PreAuthorize` genÃ©ricos

---

## 2. Objetivo

Substituir autenticaÃ§Ã£o JWT manual por **Keycloak** como Identity Provider (IdP) centralizado, mantendo:
1. **Compatibilidade**: Endpoints REST continuam funcionando sem breaking changes
2. **Multi-tenancy**: Cada tenant = 1 Realm Keycloak isolado
3. **RBAC**: Roles Keycloak mapeados para `AdminRole`, `DriverStatus`, etc.
4. **Hexagonal**: Domain e Application layers nÃ£o conhecem Keycloak

---

## 3. Escopo TÃ©cnico

### 3.1 Arquitetura Proposta

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      KEYCLOAK SERVER                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Realm: A    â”‚  â”‚  Realm: B    â”‚  â”‚  Realm: C    â”‚      â”‚
â”‚  â”‚  (Tenant A)  â”‚  â”‚  (Tenant B)  â”‚  â”‚  (Tenant C)  â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚       â†“ Users/Roles     â†“ Users/Roles     â†“ Users/Roles    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
              OpenID Connect / OAuth 2.0 (JWT)
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RAPPIDRIVE BACKEND (Spring Boot)              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Presentation Layer                                 â”‚   â”‚
â”‚  â”‚  - Controllers com @PreAuthorize("hasRole('ADMIN')")â”‚   â”‚
â”‚  â”‚  - Token extraÃ­do do header Authorization           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                        â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Infrastructure Layer                               â”‚   â”‚
â”‚  â”‚  - KeycloakJwtDecoder (valida assinatura)           â”‚   â”‚
â”‚  â”‚  - KeycloakCurrentUserAdapter (extrai claims)       â”‚   â”‚
â”‚  â”‚  - KeycloakTenantResolver (realm â†’ TenantId)        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                        â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Application Layer                                  â”‚   â”‚
â”‚  â”‚  - CurrentUserPort (interface sem Keycloak)         â”‚   â”‚
â”‚  â”‚  - Use Cases dependem apenas da porta               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                        â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Domain Layer                                       â”‚   â”‚
â”‚  â”‚  - 100% framework-free (sem imports Keycloak)       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Modelo de Multi-Tenancy

#### OpÃ§Ã£o A: Realm por Tenant (RECOMENDADO âœ…)
**Estrutura**:
```
Keycloak
â”œâ”€â”€ Realm: tenant-a (RappiDrive Tenant A)
â”‚   â”œâ”€â”€ Users: admin@a.com, driver1@a.com, passenger1@a.com
â”‚   â”œâ”€â”€ Roles: ADMIN, DRIVER, PASSENGER
â”‚   â”œâ”€â”€ Client: rappidrive-api
â”‚   â””â”€â”€ Client Scopes: admin, driver, passenger
â”‚
â”œâ”€â”€ Realm: tenant-b (RappiDrive Tenant B)
â”‚   â”œâ”€â”€ Users: admin@b.com, driver2@b.com
â”‚   â”œâ”€â”€ Roles: ADMIN, DRIVER, PASSENGER
â”‚   â””â”€â”€ Client: rappidrive-api
â”‚
â””â”€â”€ Master Realm (admin do Keycloak)
```

**Vantagens**:
- âœ… **Isolamento total**: ImpossÃ­vel leak entre tenants (garantido pelo Keycloak)
- âœ… **CustomizaÃ§Ã£o**: Cada tenant pode ter themes, policies, SSO prÃ³prios
- âœ… **Escalabilidade**: Realms exportÃ¡veis/importÃ¡veis para migraÃ§Ã£o
- âœ… **Auditoria**: Logs separados por realm

**Desvantagens**:
- âš ï¸ Provisionamento: Criar realm via Admin API para cada novo tenant
- âš ï¸ Overhead: +1 realm = +1 conexÃ£o DB, +memÃ³ria (mitigÃ¡vel com tuning)

#### OpÃ§Ã£o B: Realm Ãšnico + Groups
**Estrutura**:
```
Keycloak
â””â”€â”€ Realm: rappidrive-platform
    â”œâ”€â”€ Group: tenant-a
    â”‚   â”œâ”€â”€ Users: admin@a.com, driver1@a.com
    â”‚   â””â”€â”€ Attributes: tenantId=uuid-a
    â”œâ”€â”€ Group: tenant-b
    â”‚   â”œâ”€â”€ Users: admin@b.com
    â”‚   â””â”€â”€ Attributes: tenantId=uuid-b
```

**Vantagens**:
- âœ… Simplicidade: 1 realm para todos os tenants

**Desvantagens**:
- âŒ Risco de leak: Erro de configuraÃ§Ã£o pode expor dados entre tenants
- âŒ Menor flexibilidade: Mesmo theme/polÃ­ticas para todos

**DecisÃ£o**: **OpÃ§Ã£o A** (Realm por Tenant) para garantir isolamento mÃ¡ximo.

---

### 3.3 Mapeamento de Entidades

#### 3.3.1 Driver â†’ Keycloak User
```yaml
Keycloak User:
  id: UUID (ex: "550e8400-e29b-41d4-a716-446655440000")
  username: driver1@example.com
  email: driver1@example.com
  firstName: "JoÃ£o"
  lastName: "Silva"
  enabled: true
  attributes:
    cpf: "12345678909"
    phone: "+5511999999999"
    licenseNumber: "12345678901"
    tenantId: "uuid-tenant-a"
  realmRoles: ["DRIVER"]
```

**SincronizaÃ§Ã£o**:
- Backend **nÃ£o armazena senhas** (delegado ao Keycloak)
- Tabela `drivers` mantÃ©m referÃªncia `keycloak_user_id` (UUID)
- Evento `USER_CREATED` do Keycloak provisiona registro no backend via webhook

#### 3.3.2 Passenger â†’ Keycloak User
```yaml
Keycloak User:
  id: UUID
  username: passenger1@example.com
  email: passenger1@example.com
  firstName: "Maria"
  lastName: "Santos"
  enabled: true
  attributes:
    cpf: "98765432100"
    phone: "+5511988888888"
    tenantId: "uuid-tenant-a"
  realmRoles: ["PASSENGER"]
```

#### 3.3.3 AdminUser â†’ Keycloak User
```yaml
Keycloak User:
  id: UUID
  username: admin@rappidrive.com
  email: admin@rappidrive.com
  enabled: true
  attributes:
    tenantId: "uuid-tenant-a"
  realmRoles: ["ADMIN"]
  clientRoles:
    rappidrive-api: ["SUPER_ADMIN", "COMPLIANCE_OFFICER"]
```

**Mapping AdminRole**:
```
Keycloak Client Role â†’ Domain AdminRole
- SUPER_ADMIN          â†’ AdminRole.SUPER_ADMIN
- COMPLIANCE_OFFICER   â†’ AdminRole.COMPLIANCE_OFFICER
- SUPPORT_ADMIN        â†’ AdminRole.SUPPORT_ADMIN
```

---

### 3.4 Fluxo de AutenticaÃ§Ã£o

#### CenÃ¡rio 1: Driver faz login
```
1. Mobile App â†’ POST /realms/tenant-a/protocol/openid-connect/token
   Body: { username: "driver1@example.com", password: "***", grant_type: "password" }

2. Keycloak valida credenciais
   â†“
3. Keycloak retorna JWT:
   {
     "access_token": "eyJhbGci...",
     "token_type": "Bearer",
     "expires_in": 3600,
     "refresh_token": "eyJhbGci...",
     "scope": "driver"
   }

4. Mobile App â†’ GET /api/v1/trips/available
   Header: Authorization: Bearer eyJhbGci...

5. RappiDrive Backend valida JWT:
   - Verifica assinatura com chave pÃºblica do Keycloak
   - Extrai claims: { sub: "uuid-driver", realm_access: { roles: ["DRIVER"] } }
   - Resolve tenantId a partir do realm (tenant-a â†’ uuid-tenant-a)
   - Popula CurrentUser via CurrentUserPort

6. Use Case executa com contexto autenticado
```

#### CenÃ¡rio 2: Admin aprova motorista
```
1. Admin Web â†’ POST /realms/tenant-a/protocol/openid-connect/token
   (OAuth 2.0 Authorization Code Flow com PKCE)

2. Keycloak redireciona para login
   â†“
3. Admin autentica (com MFA se habilitado)
   â†“
4. Keycloak retorna JWT com role ADMIN + SUPER_ADMIN

5. Admin Web â†’ POST /api/v1/admin/approvals/{id}/approve
   Header: Authorization: Bearer eyJhbGci...

6. Backend valida:
   - JWT vÃ¡lido?
   - Realm correto (tenant-a)?
   - Role ADMIN presente?
   - Client role SUPER_ADMIN presente?
   â†“
7. Use Case ApproveDriverUseCase executa
```

---

### 3.5 MudanÃ§as de CÃ³digo (Camada a Camada)

#### 3.5.1 Domain Layer
**MudanÃ§as**: âŒ **ZERO** (permanece framework-free)

Domain nÃ£o conhece Keycloak. Entidades continuam:
```java
// Sem imports de Keycloak, JWT ou Spring Security
public class Driver {
    private UUID id;  // Mesmo UUID do Keycloak user
    private TenantId tenantId;
    // ...
}
```

#### 3.5.2 Application Layer
**MudanÃ§as**: âœ… MÃ­nimas

**Antes (HIST-2026-012)**:
```java
public interface CurrentUserPort {
    Optional<CurrentUser> getCurrentUser();
}

public record CurrentUser(
    UUID userId,
    String username,
    List<String> roles,
    List<String> scopes
) {}
```

**Depois (HIST-2026-014)**:
```java
public interface CurrentUserPort {
    Optional<CurrentUser> getCurrentUser();
}

public record CurrentUser(
    UUID userId,         // Keycloak user UUID
    String username,
    TenantId tenantId,   // NOVO: extraÃ­do do realm
    List<String> roles,  // Keycloak realm roles
    List<String> scopes  // Keycloak client scopes
) {}
```

**Novo Port**:
```java
// application/ports/output/IdentityProviderPort.java
public interface IdentityProviderPort {
    
    /**
     * Provisiona novo usuÃ¡rio no Keycloak
     */
    UUID createUser(CreateUserCommand command);
    
    /**
     * Atualiza atributos de usuÃ¡rio
     */
    void updateUserAttributes(UUID userId, Map<String, String> attributes);
    
    /**
     * Desabilita usuÃ¡rio (soft delete)
     */
    void disableUser(UUID userId);
    
    /**
     * Envia email de reset de senha
     */
    void sendPasswordResetEmail(UUID userId);
    
    record CreateUserCommand(
        String email,
        String firstName,
        String lastName,
        TenantId tenantId,
        Set<String> roles,
        Map<String, String> attributes
    ) {}
}
```

#### 3.5.3 Infrastructure Layer
**MudanÃ§as**: âœ… Novas implementaÃ§Ãµes

**A. KeycloakCurrentUserAdapter** (substitui `SpringSecurityCurrentUserAdapter`)
```java
// infrastructure/security/keycloak/KeycloakCurrentUserAdapter.java
@Component
@ConditionalOnProperty("keycloak.enabled")
public class KeycloakCurrentUserAdapter implements CurrentUserPort {
    
    private final KeycloakTenantResolver tenantResolver;
    
    @Override
    public Optional<CurrentUser> getCurrentUser() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (!(auth instanceof JwtAuthenticationToken jwtAuth)) {
            return Optional.empty();
        }
        
        Jwt jwt = jwtAuth.getToken();
        UUID userId = UUID.fromString(jwt.getSubject());
        String username = jwt.getClaim("preferred_username");
        
        // Extrai realm do issuer: http://keycloak:8080/realms/tenant-a
        String realm = extractRealm(jwt.getIssuer().toString());
        TenantId tenantId = tenantResolver.resolve(realm);
        
        List<String> roles = extractRealmRoles(jwt);
        List<String> scopes = extractScopes(jwt);
        
        return Optional.of(new CurrentUser(userId, username, tenantId, roles, scopes));
    }
    
    private String extractRealm(String issuer) {
        // Parse "http://keycloak:8080/realms/tenant-a" â†’ "tenant-a"
        return issuer.substring(issuer.lastIndexOf('/') + 1);
    }
    
    private List<String> extractRealmRoles(Jwt jwt) {
        Map<String, Object> realmAccess = jwt.getClaim("realm_access");
        if (realmAccess != null && realmAccess.get("roles") instanceof List<?> roles) {
            return roles.stream().map(Object::toString).toList();
        }
        return List.of();
    }
}
```

**B. KeycloakTenantResolver** (mapeia realm â†’ TenantId)
```java
// infrastructure/security/keycloak/KeycloakTenantResolver.java
@Component
public class KeycloakTenantResolver {
    
    private final Map<String, TenantId> realmToTenantCache = new ConcurrentHashMap<>();
    private final TenantRepository tenantRepository;
    
    public TenantId resolve(String realmName) {
        return realmToTenantCache.computeIfAbsent(realmName, realm -> {
            // Query DB: SELECT id FROM tenants WHERE keycloak_realm = 'tenant-a'
            return tenantRepository.findByKeycloakRealm(realm)
                .orElseThrow(() -> new UnknownTenantException(realm));
        });
    }
}
```

**C. KeycloakIdentityProviderAdapter**
```java
// infrastructure/adapters/KeycloakIdentityProviderAdapter.java
@Component
public class KeycloakIdentityProviderAdapter implements IdentityProviderPort {
    
    private final Keycloak keycloakAdminClient;
    private final KeycloakTenantResolver tenantResolver;
    
    @Override
    public UUID createUser(CreateUserCommand command) {
        String realm = resolveRealm(command.tenantId());
        
        UserRepresentation user = new UserRepresentation();
        user.setEnabled(true);
        user.setUsername(command.email());
        user.setEmail(command.email());
        user.setFirstName(command.firstName());
        user.setLastName(command.lastName());
        user.setAttributes(command.attributes());
        
        RealmResource realmResource = keycloakAdminClient.realm(realm);
        Response response = realmResource.users().create(user);
        
        if (response.getStatus() != 201) {
            throw new IdentityProviderException("Failed to create user: " + response.getStatusInfo());
        }
        
        String userId = extractUserIdFromLocation(response.getLocation());
        assignRoles(realm, UUID.fromString(userId), command.roles());
        
        return UUID.fromString(userId);
    }
    
    private String resolveRealm(TenantId tenantId) {
        // Query DB: SELECT keycloak_realm FROM tenants WHERE id = :tenantId
        // Ex: "tenant-a"
    }
}
```

**D. SecurityConfiguration atualizado**
```java
// infrastructure/config/SecurityConfiguration.java
@Configuration
@ConditionalOnProperty("keycloak.enabled")
public class KeycloakSecurityConfiguration {
    
    @Value("${keycloak.auth-server-url}")
    private String keycloakServerUrl;
    
    @Value("${keycloak.realm}")  // Para validaÃ§Ã£o, pode ser "master" ou dinÃ¢mico
    private String keycloakRealm;
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/**", "/actuator/health").permitAll()
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/v1/drivers/**").hasAnyRole("DRIVER", "ADMIN")
                .requestMatchers("/api/v1/passengers/**").hasAnyRole("PASSENGER", "ADMIN")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))
            );
        
        return http.build();
    }
    
    @Bean
    public JwtDecoder jwtDecoder() {
        // Keycloak publica chaves pÃºblicas em:
        // http://keycloak:8080/realms/{realm}/protocol/openid-connect/certs
        String jwkSetUri = keycloakServerUrl + "/realms/" + keycloakRealm + "/protocol/openid-connect/certs";
        return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
    }
    
    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        grantedAuthoritiesConverter.setAuthoritiesClaimName("realm_access.roles");
        grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_");
        
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
        return jwtAuthenticationConverter;
    }
}
```

#### 3.5.4 Presentation Layer
**MudanÃ§as**: âœ… Atualizar controllers para usar novos roles

**Antes**:
```java
@GetMapping("/approvals/pending")
@PreAuthorize("hasAuthority('SCOPE_admin')")
public List<DriverApprovalResponse> listPending() { ... }
```

**Depois**:
```java
@GetMapping("/approvals/pending")
@PreAuthorize("hasAnyRole('SUPER_ADMIN', 'COMPLIANCE_OFFICER')")
public List<DriverApprovalResponse> listPending() {
    CurrentUser currentUser = currentUserPort.getCurrentUser()
        .orElseThrow(() -> new UnauthorizedException("User not authenticated"));
    
    // Multi-tenancy enforcement: sÃ³ vÃª aprovaÃ§Ãµes do prÃ³prio tenant
    return useCase.execute(new ListPendingCommand(currentUser.tenantId()));
}
```

---

### 3.6 Database Schema Changes

**MigraÃ§Ã£o**: `V17__add_keycloak_integration.sql`

```sql
-- Adiciona coluna keycloak_realm Ã  tabela tenants
ALTER TABLE tenants
    ADD COLUMN keycloak_realm VARCHAR(255) UNIQUE;

CREATE INDEX idx_tenants_keycloak_realm ON tenants(keycloak_realm);

-- Adiciona coluna keycloak_user_id Ã s tabelas de usuÃ¡rios
ALTER TABLE drivers
    ADD COLUMN keycloak_user_id UUID UNIQUE;

ALTER TABLE passengers
    ADD COLUMN keycloak_user_id UUID UNIQUE;

ALTER TABLE admin_users
    ADD COLUMN keycloak_user_id UUID UNIQUE;

-- Ãndices para lookup rÃ¡pido
CREATE INDEX idx_drivers_keycloak_user ON drivers(keycloak_user_id);
CREATE INDEX idx_passengers_keycloak_user ON passengers(keycloak_user_id);
CREATE INDEX idx_admin_users_keycloak_user ON admin_users(keycloak_user_id);

-- Constraint para garantir 1:1 mapping
ALTER TABLE drivers
    ADD CONSTRAINT uk_driver_keycloak_user UNIQUE (keycloak_user_id);
```

---

### 3.7 ConfiguraÃ§Ã£o (application.yml)

```yaml
# application-dev.yml
keycloak:
  enabled: true
  auth-server-url: http://localhost:8180
  realm: master  # Para validaÃ§Ã£o do token
  resource: rappidrive-api
  credentials:
    secret: ${KEYCLOAK_CLIENT_SECRET}
  ssl-required: none  # Apenas dev
  use-resource-role-mappings: true
  bearer-only: true

spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: ${keycloak.auth-server-url}/realms/${keycloak.realm}/protocol/openid-connect/certs
          issuer-uri: ${keycloak.auth-server-url}/realms/${keycloak.realm}

# application-prod.yml
keycloak:
  enabled: true
  auth-server-url: https://auth.rappidrive.com
  realm: master
  ssl-required: external
  verify-token-audience: true
```

---

## 4. Casos de Uso Impactados

### 4.1 Registro de Motorista (CreateDriverUseCase)
**Antes**:
```java
Driver driver = new Driver(UUID.randomUUID(), tenantId, name, email, cpf, phone, license);
driverRepository.save(driver);
```

**Depois**:
```java
// 1. Provisiona usuÃ¡rio no Keycloak
UUID keycloakUserId = identityProviderPort.createUser(
    new CreateUserCommand(
        email.value(),
        name.firstName(),
        name.lastName(),
        tenantId,
        Set.of("DRIVER"),
        Map.of(
            "cpf", cpf.value(),
            "phone", phone.value(),
            "licenseNumber", license.number()
        )
    )
);

// 2. Cria registro no backend com referÃªncia ao Keycloak
Driver driver = new Driver(keycloakUserId, tenantId, name, email, cpf, phone, license);
driverRepository.save(driver);

// 3. Envia email de ativaÃ§Ã£o (Keycloak Actions API)
identityProviderPort.sendPasswordResetEmail(keycloakUserId);
```

### 4.2 AprovaÃ§Ã£o de Motorista (ApproveDriverUseCase)
**MudanÃ§a**: Habilitar usuÃ¡rio no Keycloak apÃ³s aprovaÃ§Ã£o

```java
public Trip execute(ApproveDriverCommand command) {
    // ... lÃ³gica existente de aprovaÃ§Ã£o
    
    // Habilita usuÃ¡rio no Keycloak para permitir login
    identityProviderPort.updateUserAttributes(
        driver.getKeycloakUserId(),
        Map.of("approved", "true")
    );
    
    // Envia notificaÃ§Ã£o de aprovaÃ§Ã£o
}
```

### 4.3 Login (Novo Controller)
**Endpoint**: `POST /api/v1/auth/login`

```java
@RestController
@RequestMapping("/api/v1/auth")
public class AuthController {
    
    private final KeycloakTokenService tokenService;
    
    @PostMapping("/login")
    public LoginResponse login(@RequestBody LoginRequest request) {
        // Delega ao Keycloak via Resource Owner Password Credentials
        TokenResponse tokens = tokenService.authenticate(
            request.tenantId(),
            request.email(),
            request.password()
        );
        
        return new LoginResponse(
            tokens.accessToken(),
            tokens.refreshToken(),
            tokens.expiresIn()
        );
    }
    
    @PostMapping("/refresh")
    public LoginResponse refresh(@RequestBody RefreshTokenRequest request) {
        TokenResponse tokens = tokenService.refreshToken(
            request.tenantId(),
            request.refreshToken()
        );
        
        return new LoginResponse(
            tokens.accessToken(),
            tokens.refreshToken(),
            tokens.expiresIn()
        );
    }
}
```

---

## 5. Plano de MigraÃ§Ã£o

### Fase 1: Setup Keycloak (Dia 1)
1. âœ… Subir Keycloak via Docker Compose
2. âœ… Criar realm `tenant-demo` para testes
3. âœ… Configurar client `rappidrive-api` (confidential, service accounts enabled)
4. âœ… Criar roles: ADMIN, DRIVER, PASSENGER
5. âœ… Criar client roles: SUPER_ADMIN, COMPLIANCE_OFFICER, SUPPORT_ADMIN

### Fase 2: ImplementaÃ§Ã£o Backend (Dias 2-4)
1. âœ… Adicionar dependÃªncia Keycloak Admin Client
2. âœ… Criar `IdentityProviderPort` + `KeycloakIdentityProviderAdapter`
3. âœ… Atualizar `CurrentUserPort` para incluir `TenantId`
4. âœ… Implementar `KeycloakCurrentUserAdapter`
5. âœ… Implementar `KeycloakTenantResolver`
6. âœ… Atualizar `SecurityConfiguration` para usar Keycloak JWT
7. âœ… MigraÃ§Ã£o V17: adicionar colunas `keycloak_user_id` e `keycloak_realm`
8. âœ… Atualizar use cases de registro (Driver, Passenger, Admin)

### Fase 3: Testes (Dia 5)
1. âœ… Testes unitÃ¡rios dos adapters com Keycloak mockado
2. âœ… Testes de integraÃ§Ã£o com Testcontainers Keycloak
3. âœ… Testes E2E de fluxo completo (registro â†’ login â†’ operaÃ§Ã£o)

### Fase 4: MigraÃ§Ã£o de Dados (Dia 6)
1. âœ… Script para provisionar usuÃ¡rios existentes no Keycloak
2. âœ… Popular `keycloak_user_id` em drivers/passengers/admins existentes
3. âœ… ValidaÃ§Ã£o: todos os usuÃ¡rios tÃªm `keycloak_user_id` nÃ£o-nulo

### Fase 5: Deploy & Rollback Plan (Dia 7)
1. âœ… Deploy em staging com feature flag `keycloak.enabled=true`
2. âœ… Smoke tests
3. âœ… Rollback plan: reverter para JWT manual se necessÃ¡rio

---

## 6. DependÃªncias Maven

```xml
<!-- Keycloak Admin Client -->
<dependency>
    <groupId>org.keycloak</groupId>
    <artifactId>keycloak-admin-client</artifactId>
    <version>23.0.3</version>
</dependency>

<!-- Spring Security OAuth2 Resource Server (jÃ¡ existe) -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>

<!-- Para testes -->
<dependency>
    <groupId>com.github.dasniko</groupId>
    <artifactId>testcontainers-keycloak</artifactId>
    <version>3.1.0</version>
    <scope>test</scope>
</dependency>
```

---

## 7. Docker Compose Atualizado

```yaml
# docker-compose.yml
version: '3.8'

services:
  keycloak:
    image: quay.io/keycloak/keycloak:23.0.3
    container_name: rappidrive-keycloak
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak_db
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: keycloak_password
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
      KC_HOSTNAME_STRICT: false
      KC_HTTP_ENABLED: true
    ports:
      - "8180:8080"  # Admin Console: http://localhost:8180
    depends_on:
      - postgres
    networks:
      - rappidrive-network
    command: start-dev

  postgres:
    # ... configuraÃ§Ã£o existente
    environment:
      # Adicionar database para Keycloak
      POSTGRES_MULTIPLE_DATABASES: rappidrive_dev,keycloak_db
```

**Init script** (`docker/init-scripts/03-create-keycloak-db.sh`):
```bash
#!/bin/bash
psql -U rappidrive -c "CREATE DATABASE keycloak_db;"
psql -U rappidrive -c "CREATE USER keycloak WITH PASSWORD 'keycloak_password';"
psql -U rappidrive -c "GRANT ALL PRIVILEGES ON DATABASE keycloak_db TO keycloak;"
```

---

## 8. CritÃ©rios de Aceite

### âœ… CA-001: Keycloak Rodando
**DADO** Docker Compose up  
**QUANDO** acesso http://localhost:8180  
**ENTÃƒO** Keycloak Admin Console estÃ¡ acessÃ­vel (admin/admin)

### âœ… CA-002: Realm Multi-Tenant
**DADO** 2 tenants: A e B  
**QUANDO** tenants sÃ£o provisionados  
**ENTÃƒO** existem realms `tenant-a` e `tenant-b` no Keycloak

### âœ… CA-003: Registro de Motorista
**DADO** tenant A  
**QUANDO** POST /api/v1/drivers  
```json
{
  "name": "JoÃ£o Silva",
  "email": "joao@example.com",
  "cpf": "12345678909",
  "phone": "+5511999999999",
  "license": { "number": "12345678901", "category": "B" }
}
```
**ENTÃƒO**:
- UsuÃ¡rio criado no Keycloak realm `tenant-a` com role DRIVER
- Registro criado na tabela `drivers` com `keycloak_user_id` populado
- Email de ativaÃ§Ã£o enviado

### âœ… CA-004: Login
**DADO** motorista registrado  
**QUANDO** POST /api/v1/auth/login  
```json
{
  "tenantId": "uuid-tenant-a",
  "email": "joao@example.com",
  "password": "senha123"
}
```
**ENTÃƒO**:
- Retorna `access_token` JWT vÃ¡lido
- Retorna `refresh_token`
- `expires_in` = 3600 segundos

### âœ… CA-005: ValidaÃ§Ã£o JWT
**DADO** token obtido do Keycloak  
**QUANDO** GET /api/v1/trips/available  
```
Authorization: Bearer eyJhbGci...
```
**ENTÃƒO**:
- Backend valida assinatura com chave pÃºblica do Keycloak
- Extrai `tenantId` do realm
- Popula `CurrentUser` com roles corretos
- Use case executa com sucesso

### âœ… CA-006: Isolamento Multi-Tenant
**DADO** motorista A logado (tenant A)  
**QUANDO** tenta acessar recurso do tenant B  
**ENTÃƒO** 403 Forbidden (violaÃ§Ã£o de tenant isolation)

### âœ… CA-007: RBAC Admin
**DADO** usuÃ¡rio com role SUPPORT_ADMIN  
**QUANDO** POST /api/v1/admin/approvals/{id}/approve  
**ENTÃƒO** 403 Forbidden (sÃ³ SUPER_ADMIN e COMPLIANCE_OFFICER podem aprovar)

### âœ… CA-008: SSO (Futuro)
**DADO** tenant com Google SSO configurado no Keycloak  
**QUANDO** motorista faz login via Google  
**ENTÃƒO** autenticaÃ§Ã£o delegada ao Google e JWT gerado

### âœ… CA-009: MFA (Futuro)
**DADO** tenant com MFA habilitado  
**QUANDO** admin faz login  
**ENTÃƒO** Keycloak solicita segundo fator (TOTP)

### âœ… CA-010: MigraÃ§Ã£o de Dados
**DADO** 1000 motoristas existentes no banco  
**QUANDO** script de migraÃ§Ã£o executa  
**ENTÃƒO**:
- 1000 usuÃ¡rios criados no Keycloak realm correto
- Tabela `drivers` atualizada com `keycloak_user_id`
- Zero duplicatas

---

## 9. Riscos & MitigaÃ§Ãµes

| Risco | Probabilidade | Impacto | MitigaÃ§Ã£o |
|-------|:-------------:|:-------:|-----------|
| **Performance**: LatÃªncia na validaÃ§Ã£o JWT | MÃ©dia | MÃ©dio | Cache de chaves pÃºblicas JWK (Spring Security faz automaticamente) |
| **Single Point of Failure**: Keycloak down = ninguÃ©m loga | Alta | Alto | HA setup (Keycloak cluster + load balancer), healthchecks, circuit breakers |
| **Complexidade**: Curva de aprendizado Keycloak | MÃ©dia | MÃ©dio | Treinamento da equipe, documentaÃ§Ã£o robusta, runbooks |
| **MigraÃ§Ã£o**: Erro ao provisionar usuÃ¡rios existentes | MÃ©dia | Alto | Testes extensivos, rollback plan, script idempotente |
| **Multi-tenancy leak**: ConfiguraÃ§Ã£o errada de realm | Baixa | CrÃ­tico | Testes automatizados de isolamento, code review rigoroso |

---

## 10. Testes

### 10.1 Testes UnitÃ¡rios
```java
// KeycloakCurrentUserAdapterTest.java
@Test
void shouldExtractTenantIdFromRealmInJwt() {
    Jwt jwt = mockJwt("http://keycloak:8080/realms/tenant-a");
    when(tenantResolver.resolve("tenant-a")).thenReturn(tenantId);
    
    Optional<CurrentUser> user = adapter.getCurrentUser();
    
    assertThat(user).isPresent();
    assertThat(user.get().tenantId()).isEqualTo(tenantId);
}
```

### 10.2 Testes de IntegraÃ§Ã£o
```java
// KeycloakIntegrationTest.java
@Testcontainers
@SpringBootTest
class KeycloakIntegrationTest {
    
    @Container
    static KeycloakContainer keycloak = new KeycloakContainer()
        .withRealmImportFile("keycloak-realm-test.json");
    
    @Test
    void shouldAuthenticateDriverAndGetToken() {
        // 1. Cria usuÃ¡rio via Admin API
        UUID userId = keycloakAdapter.createUser(command);
        
        // 2. Faz login
        TokenResponse tokens = tokenService.authenticate(
            tenantId, "driver@test.com", "password"
        );
        
        // 3. Valida token
        assertThat(tokens.accessToken()).isNotBlank();
        assertThat(jwtDecoder.decode(tokens.accessToken())).isNotNull();
    }
}
```

### 10.3 Testes E2E
```java
@Test
void shouldCompleteDriverJourneyWithKeycloak() {
    // 1. Admin cria motorista
    mockMvc.perform(post("/api/v1/drivers")
        .header("Authorization", "Bearer " + adminToken)
        .contentType(APPLICATION_JSON)
        .content(driverJson))
        .andExpect(status().isCreated());
    
    // 2. Motorista ativa conta (via link no email)
    // 3. Motorista faz login
    String driverToken = authenticateDriver("driver@test.com", "newPassword");
    
    // 4. Motorista lista corridas disponÃ­veis
    mockMvc.perform(get("/api/v1/trips/available")
        .header("Authorization", "Bearer " + driverToken))
        .andExpect(status().isOk());
}
```

---

## 11. DocumentaÃ§Ã£o & Runbooks

### 11.1 README Atualizado
```markdown
## AutenticaÃ§Ã£o com Keycloak

### Setup Local
1. Subir Keycloak: `docker-compose up -d keycloak`
2. Acessar Admin Console: http://localhost:8180 (admin/admin)
3. Importar realm de teste: `Import > keycloak-realm-dev.json`

### Obter Token (cURL)
```bash
curl -X POST http://localhost:8180/realms/tenant-a/protocol/openid-connect/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "client_id=rappidrive-api" \
  -d "client_secret=your-secret" \
  -d "grant_type=password" \
  -d "username=driver@example.com" \
  -d "password=senha123"
```

### Troubleshooting
- **401 Unauthorized**: Verificar se realm estÃ¡ correto no `application.yml`
- **403 Forbidden**: Verificar se role estÃ¡ atribuÃ­da ao usuÃ¡rio no Keycloak
- **Keycloak down**: Ver logs com `docker logs rappidrive-keycloak`
```

### 11.2 Runbook: Keycloak IndisponÃ­vel
```markdown
## Runbook: Keycloak Down

### Sintomas
- UsuÃ¡rios nÃ£o conseguem logar
- Erro: "Unable to obtain JWK Set from: http://keycloak:8080/..."

### DiagnÃ³stico
1. Verificar status: `docker ps | grep keycloak`
2. Verificar logs: `docker logs rappidrive-keycloak --tail=100`
3. Verificar conectividade: `curl http://localhost:8180/health`

### ResoluÃ§Ã£o
**OpÃ§Ã£o 1**: Restart
```bash
docker restart rappidrive-keycloak
```

**OpÃ§Ã£o 2**: Rollback para JWT manual
```yaml
# application.yml
keycloak:
  enabled: false  # Desabilita Keycloak
```
Redeploy da aplicaÃ§Ã£o com autenticaÃ§Ã£o JWT manual temporÃ¡ria.

**OpÃ§Ã£o 3**: Failover para replica (em produÃ§Ã£o)
- Atualizar DNS para apontar para instÃ¢ncia secundÃ¡ria
```

---

## 12. PrÃ³ximas HistÃ³rias (Futuras)

### HIST-2026-015: SSO com Google/Microsoft
- Configurar Identity Providers no Keycloak
- Testar fluxo OAuth 2.0 com providers externos

### HIST-2026-016: MFA para Admins
- Habilitar TOTP (Google Authenticator) para role ADMIN
- PolÃ­ticas de senha forte

### HIST-2026-017: User Federation (LDAP)
- Integrar com Active Directory corporativo
- SincronizaÃ§Ã£o de usuÃ¡rios via LDAP

### HIST-2026-018: Fine-Grained Authorization
- Keycloak Authorization Services (UMA)
- PolÃ­ticas baseadas em recursos (ex: "Motorista sÃ³ pode editar prÃ³prio perfil")

---

## 13. ConclusÃ£o

Esta histÃ³ria transforma o RappiDrive em uma plataforma **enterprise-ready** com:
- âœ… **SeguranÃ§a**: AutenticaÃ§Ã£o delegada a Keycloak (battle-tested)
- âœ… **Escalabilidade**: Multi-tenancy nativo com isolamento total
- âœ… **Flexibilidade**: SSO, MFA, federaÃ§Ã£o prontos para ativar
- âœ… **Manutenibilidade**: Zero cÃ³digo de autenticaÃ§Ã£o manual
- âœ… **Arquitetura**: Hexagonal preservado com ports/adapters

**Investimento**: 5-7 dias  
**ROI**: ReduÃ§Ã£o de 80% no cÃ³digo de autenticaÃ§Ã£o, compliance LGPD/GDPR, reduÃ§Ã£o de vulnerabilidades

---

**Aprovado por**: _[Tech Lead]_  
**Data de inÃ­cio prevista**: _[A definir]_  
**Sprint**: _[A definir]_
