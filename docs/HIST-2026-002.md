# HIST-2026-002 ‚Äî Outbox pattern para entrega confi√°vel de eventos üîÅüì®

## Contexto
Depois de implementar Optimistic Locking e events no fluxo de cria√ß√£o/aceita√ß√£o de corridas, precisamos garantir que eventos de dom√≠nio (ex.: `TripCreatedEvent`, `TripDriverAssignedEvent`) sejam entregues de forma *confi√°vel* e *observ√°vel* mesmo diante de falhas (app crash, rede, etc.). O padr√£o Outbox resolve isso preservando atomicidade entre mudan√ßa de estado e persist√™ncia do evento.

## Objetivo
Implementar um pipeline Outbox que:
- Persista eventos em DB na mesma transa√ß√£o que a mudan√ßa do agregado;
- Publique os eventos de forma resiliente (retries, backoff, DLQ);
- Forne√ßa m√©tricas/observabilidade;
- Preserve a separa√ß√£o hexagonal (ports/adapters + domain puro).

## Crit√©rios de Aceita√ß√£o ‚úÖ
1. Eventos s√£o gravados em tabela `outbox_event` na mesma transa√ß√£o que a altera√ß√£o do agregado.
2. Publisher agendado consome linhas `PENDING`, publica via `EventDispatcherPort` e marca `SENT` / `FAILED` com retry/backoff.
3. Em caso de falha na publica√ß√£o, h√° retry com backoff e limite de tentativas (dead-letter).
4. Testes unit√°rios + integra√ß√£o (Testcontainers) comprovam que eventos n√£o s√£o perdidos e que duplica√ß√µes s√£o trat√°veis (idempot√™ncia por `eventId`).
5. M√©tricas e logs suficientes para operar (pending count, failed, published rate).

## Tarefas (seguir a numera√ß√£o)

### 1) DB migration & JPA entity (Infra)
- Criar migra√ß√£o Flyway (ex: `V10__create_outbox_table.sql`):

```sql
CREATE TABLE outbox_event (
  id UUID PRIMARY KEY,
  aggregate_id UUID,
  event_type VARCHAR(255) NOT NULL,
  payload JSONB NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
  attempts INT NOT NULL DEFAULT 0,
  next_attempt_at TIMESTAMP NULL,
  created_at TIMESTAMP NOT NULL DEFAULT now(),
  sent_at TIMESTAMP NULL
);
CREATE INDEX idx_outbox_status_next_attempt ON outbox_event(status, next_attempt_at);
```

- Adicionar JPA entity `OutboxEventJpaEntity` com campos correspondentes (use `@Entity`, `@Table`).

### 2) Outbox Port + Adapter (Infra ‚áÑ App)
- **Output Port** (application/ports/output):
  - `interface OutboxRepositoryPort { void save(OutboxEvent event); List<OutboxEvent> findPendingBatch(int limit); void markSent(UUID id); void incrementAttempts(UUID id, Instant nextAttemptAt); void markFailed(UUID id); }`
- **Adapter Implementation** em `infrastructure`: `JpaOutboxRepositoryAdapter` que usa `SpringDataOutboxRepository` (Spring Data JPA) e participa da mesma transa√ß√£o que use cases.

### 3) Domain events collection (Application layer)
- Usar `DomainEventPublisher` ou adicionar `DomainEventsCollector` que acumula eventos do dom√≠nio durante a execu√ß√£o do use case.
- Fluxo no use case:
  - alterar agregado e persistir; 
  - coletar eventos e persistir linhas no outbox via `OutboxRepositoryPort.save(...)` (participante da mesma transa√ß√£o JDBC/JPA).

> Nota: √© cr√≠tico que `OutboxRepositoryPort.save` participe da mesma transa√ß√£o JPA ‚Äî assim commit garante que evento e estado v√£o juntos.

### 4) OutboxPublisher (Infra background worker)
- Implementar `OutboxPublisher`: scheduled task que busca eventos `PENDING` com `next_attempt_at <= now()`.
- Para cada evento: chama `EventDispatcherPort.dispatch(eventId, payload)`; marca `SENT` no sucesso, ou incrementa `attempts` e agenda `next_attempt_at` em caso de falha; se `attempts >= MAX` marca `FAILED` e envia alerta/log.
- Configur√°vel: batch size, max attempts, base backoff.

### 5) EventDispatcherPort (Output port) + Adapters
- Definir `EventDispatcherPort` (envia payload JSON para Kafka/HTTP/etc.).
- Implementar adapter de teste (in-memory) e deixar espa√ßo para implementar Kafka/HTTP no futuro.

### 6) Tests
- **Unit tests**:
  - `JpaOutboxRepositoryAdapterTest`: save/find/markSent/increment.
  - `OutboxPublisherTest`: sucessos, falhas e DLQ.
  - `AssignDriverToTripUseCaseTest`: mock `OutboxRepositoryPort` e garantir a linha do outbox √© criada no fluxo.
- **Integration tests** (Testcontainers Postgres):
  - Salvar trip -> outbox row existe -> executar publisher -> dispatcher recebe e outbox marcado SENT.
  - Simular falha do publisher e verificar retry/recovery.
  - Concorr√™ncia: dois accepts concurrents -> apenas um sucesso e apenas um evento publicado.

### 7) Observability & Ops
- M√©tricas: `outbox_events_pending_total`, `outbox_events_sent_total`, `outbox_events_failed_total`, `outbox_publisher_batch_size`.
- Logs: event id, aggregate id, attempts, reason.
- Health check / alert: warn when backlog > threshold.

### 8) Migration & rollout plan
- Deploy com publisher desabilitado (feature flag);
- Validar outbox rows s√£o criadas; habilitar publisher; monitorar backoff/failures; set alert.


## Riscos & Mitiga√ß√µes ‚ö†Ô∏è
- Duplicate delivery: use eventId and recomender consumer-side idempotency; considerar dedupe store se necess√°rio.
- Backlog growth: monitor + alert.
- Complexidade transacional: garantir mesma transa√ß√£o JPA para state + outbox persists.

## Estimativa (T-shirt)
- MVP: M
- Robustness + integration tests + metrics: M ‚Üí L

## PR checklist
- [ ] migration included
- [ ] JPA entity + adapter implemented
- [ ] OutboxPort + EventDispatcherPort added
- [ ] Publisher implemented + config params
- [ ] Unit & integration tests
- [ ] Docs updated (`docs/HIST-2026-002.md`)
- [ ] Metrics and health check

---

Se quiser que eu comece agora, eu implemento o passo 1 (migra√ß√£o Flyway + JPA + testes unit√°rios) diretamente na branch `main` conforme combinado.