> Este documento é histórico e pode conter implementações obsoletas. Consulte HIST-2026-012 para a referência atual.

# HIST-2025-009 - Integração Trip-Payment e Finalização Automática de Corrida

**Data**: 03/01/2026  
**Tipo**: Feature  
**Módulo**: Trip + Payment Integration  
**Prioridade**: Alta  
**Estimativa**: 3 pontos

## Contexto

Atualmente os módulos de Trip (HIST-2025-004) e Payment (HIST-2025-008) funcionam de forma independente. Para o MVP do RappiDrive, precisamos implementar a integração entre eles para:

1. Calcular automaticamente a tarifa quando uma corrida é completada
2. Processar o pagamento automaticamente após a conclusão
3. Atualizar o status da corrida com base no resultado do pagamento
4. Garantir consistência entre corrida e pagamento

## Objetivo

Implementar a integração completa entre os módulos de Trip e Payment, permitindo que ao finalizar uma corrida:
- A tarifa seja calculada automaticamente com base na distância/tempo real
- O pagamento seja processado usando o método escolhido pelo passageiro
- A corrida seja marcada como "paga" ou "pagamento pendente" conforme resultado
- Motorista receba a informação do valor que vai receber (total - comissão)

## Requisitos Funcionais

### RF-1: Cálculo Automático de Tarifa ao Completar Corrida
- **Dado** que uma corrida foi iniciada e está em andamento
- **Quando** o motorista marca a corrida como "COMPLETED"
- **Então** o sistema deve:
  - Calcular distância real percorrida (usando pickup e dropoff locations)
  - Calcular duração real (completedAt - startedAt)
  - Buscar a configuração de tarifa do tenant
  - Calcular a tarifa usando os valores reais
  - Criar uma entidade Fare associada ao Trip
  - Armazenar o breakdown detalhado da tarifa

### RF-2: Processamento Automático de Pagamento
- **Dado** que a tarifa foi calculada para uma corrida completada
- **Quando** a corrida é finalizada
- **Então** o sistema deve:
  - Criar um Payment associado ao Trip
  - Processar o pagamento usando o método escolhido
  - Se cartão/PIX: integrar com payment gateway
  - Se dinheiro: marcar como COMPLETED diretamente
  - Calcular comissão da plataforma
  - Calcular valor do motorista
  - Atualizar status da corrida conforme resultado

### RF-3: Atualização de Status da Corrida
- **Dado** que o pagamento foi processado
- **Quando** o resultado é obtido
- **Então** o sistema deve:
  - Se pagamento COMPLETED: marcar corrida como PAID
  - Se pagamento FAILED: marcar corrida como PAYMENT_PENDING
  - Se pagamento PROCESSING: manter corrida em COMPLETED
  - Armazenar referência do Payment no Trip

### RF-4: Consulta de Detalhes Financeiros da Corrida
- Endpoint para buscar corrida com detalhes de pagamento
- Mostrar breakdown da tarifa
- Mostrar valor total, comissão, valor do motorista
- Mostrar status do pagamento
- Mostrar método de pagamento usado

## Requisitos Não-Funcionais

### RNF-1: Consistência Transacional
- O processo de finalização (cálculo tarifa + pagamento) deve ser atômico
- Se pagamento falhar, corrida não deve ser marcada como paga
- Usar transações para garantir consistência

### RNF-2: Idempotência
- Múltiplas chamadas para completar a mesma corrida não devem criar múltiplos pagamentos
- Usar constraint UNIQUE no banco (trip_id no payments)
- Verificar se pagamento já existe antes de criar novo

### RNF-3: Auditoria
- Registrar timestamps de cada etapa (calculated_at, processed_at)
- Manter histórico de tentativas de pagamento falhas
- Log detalhado para debugging

### RNF-4: Performance
- Processo de finalização deve completar em < 5 segundos
- Cálculos de distância devem usar funções nativas do PostGIS
- Evitar N+1 queries ao buscar trip com pagamento

## Regras de Negócio

### RN-1: Validações Antes de Completar
- Corrida deve estar no status STARTED
- Motorista deve estar atribuído
- Pickup e dropoff locations devem estar definidos
- Distância mínima de 0.1 km
- Duração mínima de 1 minuto

### RN-2: Cálculo de Distância
- Usar função PostGIS `ST_Distance_Sphere` para cálculo preciso
- Converter resultado de metros para quilômetros
- Arredondar para 2 casas decimais

### RN-3: Pagamento em Dinheiro
- Não requer processamento via gateway
- Marcar como COMPLETED imediatamente
- Motorista é responsável por coletar o valor
- Sistema registra que valor foi pago em dinheiro

### RN-4: Tentativas de Pagamento
- Em caso de falha no gateway, não retentar automaticamente
- Passageiro ou admin deve iniciar retry manual
- Corrida fica em PAYMENT_PENDING
- Motorista é notificado da pendência

### RN-5: Comissão da Plataforma
- Usar taxa configurada no FareConfiguration do tenant
- Comissão calculada sobre valor total da corrida
- Valor do motorista = total - comissão
- Breakdown deve ser transparente para todas as partes

## Modelo de Dados

### Alterações em Trip Entity

```java
public class Trip {
    // ... campos existentes ...
    
    private UUID fareId;              // Referência para Fare calculada
    private UUID paymentId;           // Referência para Payment processado
    private TripPaymentStatus paymentStatus; // PENDING, PAID, FAILED
    
    // Método para completar com pagamento
    public void completeWithPayment(Fare fare, Payment payment) {
        // Validar estado
        // Associar fare e payment
        // Atualizar status
    }
}
```

### Novo Enum: TripPaymentStatus

```java
public enum TripPaymentStatus {
    PENDING,           // Pagamento ainda não processado
    PROCESSING,        // Pagamento em processamento
    PAID,              // Pagamento confirmado
    PAYMENT_FAILED,    // Pagamento falhou
    REFUNDED           // Pagamento foi reembolsado
}
```

### Migration V6

```sql
-- Adicionar colunas no Trip
ALTER TABLE trips ADD COLUMN fare_id UUID;
ALTER TABLE trips ADD COLUMN payment_id UUID;
ALTER TABLE trips ADD COLUMN payment_status VARCHAR(20) DEFAULT 'PENDING';

-- Foreign keys
ALTER TABLE trips ADD CONSTRAINT fk_trip_fare 
    FOREIGN KEY (fare_id) REFERENCES fares(id);
ALTER TABLE trips ADD CONSTRAINT fk_trip_payment 
    FOREIGN KEY (payment_id) REFERENCES payments(id);

-- Índices
CREATE INDEX idx_trip_payment_status ON trips(payment_status);
CREATE INDEX idx_trip_fare ON trips(fare_id);
CREATE INDEX idx_trip_payment ON trips(payment_id);
```

## Implementação

### Camada de Domínio

#### 1. Atualizar Trip Entity
- Adicionar campos fareId, paymentId, paymentStatus
- Adicionar método `completeWithPayment(Fare, Payment)`
- Adicionar validações de estado
- Atualizar método `complete()` existente

#### 2. Criar TripPaymentStatus Enum
- Definir estados possíveis
- Métodos helper para transições válidas

#### 3. Criar TripCompletionService (Domain Service)
- Orquestrar lógica complexa de finalização
- Validar regras de negócio
- Coordenar Fare, Payment e Trip

### Camada de Aplicação

#### 1. Novo Use Case: CompleteTripWithPaymentUseCase
**Input Port**:
```java
public interface CompleteTripWithPaymentInputPort {
    TripCompletionResult execute(CompleteTripWithPaymentCommand command);
    
    record CompleteTripWithPaymentCommand(
        UUID tripId,
        Location dropoffLocation,
        PaymentMethod paymentMethod
    ) {}
}
```

**Output**: 
```java
public record TripCompletionResult(
    Trip trip,
    Fare fare,
    Payment payment,
    boolean paymentSuccessful,
    String failureReason
) {}
```

**Fluxo**:
1. Buscar Trip por ID
2. Validar que está STARTED
3. Calcular distância real (pickup → dropoff)
4. Calcular duração real
5. Calcular Fare usando FareConfiguration
6. Criar Payment
7. Processar Payment via gateway
8. Atualizar Trip com Fare, Payment e status
9. Salvar tudo
10. Retornar resultado

#### 2. Atualizar CompleteTripUseCase Existente
- Deprecar ou remover se não for mais usado
- Ou manter para casos onde pagamento é posterior

#### 3. Novo Query Use Case: GetTripWithPaymentDetailsInputPort
- Retornar Trip + Fare + Payment em uma única query
- DTO com breakdown completo

### Camada de Infraestrutura

#### 1. Criar FareJpaEntity
```java
@Entity
@Table(name = "fares")
public class FareJpaEntity {
    @Id
    private UUID id;
    private UUID tripId;
    private UUID tenantId;
    private BigDecimal baseFare;
    private Double distanceKm;
    private Integer durationMinutes;
    private BigDecimal distanceFare;
    private BigDecimal timeFare;
    private BigDecimal totalAmount;
    // ... breakdown fields
}
```

#### 2. Criar FareRepositoryPort e Adapter
- Salvar Fare
- Buscar por tripId
- Buscar por tenant e período (relatórios)

#### 3. Atualizar TripJpaEntity
- Adicionar fareId, paymentId, paymentStatus
- Mapeamento das relações

#### 4. Criar DistanceCalculationService
- Interface no application/ports/output
- Implementação usando PostGIS
- Método: `calculateDistance(Location from, Location to): double`

#### 5. Migration V6
- Criar tabela fares
- Adicionar colunas em trips
- Foreign keys e índices

### Camada de Apresentação

#### 1. Novo Endpoint: POST /api/v1/trips/{id}/complete-with-payment
**Request**:
```json
{
  "dropoffLocation": {
    "latitude": -23.5505,
    "longitude": -46.6333
  },
  "paymentMethod": {
    "type": "CREDIT_CARD",
    "cardLast4": "1234",
    "cardBrand": "VISA"
  }
}
```

**Response**:
```json
{
  "trip": {
    "id": "uuid",
    "status": "COMPLETED",
    "paymentStatus": "PAID",
    ...
  },
  "fare": {
    "totalAmount": 25.50,
    "breakdown": {
      "baseFare": 5.00,
      "distanceFare": 15.00,
      "timeFare": 3.00,
      "multipliers": {...}
    }
  },
  "payment": {
    "id": "uuid",
    "amount": 25.50,
    "platformFee": 5.10,
    "driverAmount": 20.40,
    "status": "COMPLETED"
  }
}
```

#### 2. Atualizar GET /api/v1/trips/{id}
- Incluir fareId, paymentId, paymentStatus
- Opcional: incluir detalhes do pagamento (query param)

#### 3. Novo Endpoint: GET /api/v1/trips/{id}/payment-details
- Retornar breakdown completo
- Informações financeiras da corrida

## Casos de Teste

### Teste 1: Completar Corrida com Pagamento em Cartão - Sucesso
```java
@Test
void shouldCompleteTripAndProcessCardPayment() {
    // Given: corrida STARTED
    // When: completar com cartão
    // Then: 
    //   - Fare calculada corretamente
    //   - Payment COMPLETED
    //   - Trip status = COMPLETED
    //   - Trip paymentStatus = PAID
}
```

### Teste 2: Completar Corrida com Pagamento em Dinheiro
```java
@Test
void shouldCompleteTripWithCashPayment() {
    // Given: corrida STARTED
    // When: completar com dinheiro
    // Then:
    //   - Payment criado com status COMPLETED
    //   - Não chamar payment gateway
    //   - Trip paymentStatus = PAID
}
```

### Teste 3: Falha no Pagamento via Gateway
```java
@Test
void shouldHandlePaymentGatewayFailure() {
    // Given: corrida STARTED, gateway retorna erro
    // When: completar com cartão
    // Then:
    //   - Fare calculada
    //   - Payment status = FAILED
    //   - Trip status = COMPLETED
    //   - Trip paymentStatus = PAYMENT_FAILED
    //   - failureReason preenchido
}
```

### Teste 4: Idempotência - Múltiplas Chamadas
```java
@Test
void shouldBeIdempotentOnMultipleCompletionAttempts() {
    // Given: corrida já completada e paga
    // When: tentar completar novamente
    // Then:
    //   - Lançar exceção ou retornar resultado existente
    //   - Não criar pagamento duplicado
}
```

### Teste 5: Validação - Corrida Não Iniciada
```java
@Test
void shouldNotCompleteIfTripNotStarted() {
    // Given: corrida em WAITING_DRIVER
    // When: tentar completar
    // Then: lançar TripNotStartedException
}
```

### Teste 6: Cálculo de Distância Usando PostGIS
```java
@Test
void shouldCalculateDistanceUsingPostGIS() {
    // Given: pickup e dropoff locations
    // When: calcular distância
    // Then: retornar valor correto em km
}
```

## Critérios de Aceitação

- [ ] Corrida pode ser completada com cálculo automático de tarifa
- [ ] Pagamento é processado automaticamente na finalização
- [ ] Status da corrida reflete resultado do pagamento
- [ ] Pagamento em dinheiro não chama gateway
- [ ] Cálculo de distância usa PostGIS
- [ ] Múltiplas tentativas de completar mesma corrida não criam duplicatas
- [ ] Breakdown de tarifa é armazenado e consultável
- [ ] Comissão da plataforma é calculada corretamente
- [ ] Migration V6 executada com sucesso
- [ ] Todos os testes unitários passando
- [ ] Testes de integração com banco de dados passando
- [ ] Documentação de API atualizada

## Impactos e Dependências

**Dependências**:
- ✅ HIST-2025-004 (Trip) - concluída
- ✅ HIST-2025-008 (Payment/Fare) - concluída

**Impactos**:
- Módulo Trip: adicionar 3 campos, atualizar entity
- Módulo Payment: nenhuma alteração necessária
- Módulo Fare: criar infraestrutura completa (novo)
- Database: Migration V6 (criar fares, alterar trips)
- API: novos endpoints, alterar resposta de GET trip

## Observações Técnicas

### Transação Distribuída
Embora Trip, Fare e Payment sejam entidades separadas, o processo de finalização deve ser transacional. Usar `@Transactional` no use case para garantir rollback em caso de erro.

### Cálculo de Distância
Usar PostGIS `ST_Distance_Sphere` que calcula distância geodésica (considera curvatura da Terra). Mais preciso que cálculo euclidiano simples.

### Retry de Pagamento
Não implementar retry automático nesta história. Se payment gateway falhar:
1. Marcar como PAYMENT_FAILED
2. Permitir retry manual via endpoint separado (futura história)
3. Notificar passageiro e admin

### Integração Futura
Esta história prepara base para:
- HIST-2025-010: Notificações (notificar passageiro sobre cobrança)
- HIST-2025-011: Ratings (só permitir após pagamento confirmado)
- HIST-2025-012: Dashboard motorista (mostrar earnings)

## Checklist de Implementação

### Domínio
- [ ] Criar TripPaymentStatus enum
- [ ] Atualizar Trip entity (fareId, paymentId, paymentStatus)
- [ ] Criar método Trip.completeWithPayment()
- [ ] Criar TripCompletionService (domain service)
- [ ] Testes unitários do domínio

### Aplicação
- [ ] Criar CompleteTripWithPaymentInputPort
- [ ] Criar CompleteTripWithPaymentUseCase
- [ ] Criar GetTripWithPaymentDetailsInputPort
- [ ] Criar FareRepositoryPort (output)
- [ ] Criar DistanceCalculationPort (output)
- [ ] Testes dos use cases com mocks

### Infraestrutura
- [ ] Criar FareJpaEntity
- [ ] Criar SpringDataFareRepository
- [ ] Criar FareMapper
- [ ] Criar JpaFareRepositoryAdapter
- [ ] Criar PostGISDistanceCalculationAdapter
- [ ] Atualizar TripJpaEntity
- [ ] Criar Migration V6
- [ ] Atualizar UseCaseConfiguration
- [ ] Testes de integração com Testcontainers

### Apresentação
- [ ] Criar CompleteTripWithPaymentRequest DTO
- [ ] Criar TripWithPaymentDetailsResponse DTO
- [ ] Atualizar TripResponse (fareId, paymentId, paymentStatus)
- [ ] Criar endpoint POST /trips/{id}/complete-with-payment
- [ ] Criar endpoint GET /trips/{id}/payment-details
- [ ] Atualizar TripDtoMapper
- [ ] Testes de controller com MockMvc

### Testes E2E
- [ ] Teste: completar corrida com cartão - sucesso
- [ ] Teste: completar corrida com dinheiro
- [ ] Teste: completar corrida - falha no gateway
- [ ] Teste: idempotência
- [ ] Teste: validações de estado

### Documentação
- [ ] Atualizar README com novo fluxo
- [ ] Documentar endpoints novos
- [ ] Atualizar diagramas de arquitetura
