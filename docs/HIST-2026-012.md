# HIST-2026-012: Driver Approval Workflow (Administrative Layer)

**Data**: 10/01/2026  
**Status**: PROPOSTO  
**Tipo**: Feature / Fluxo Administrativo  
**Tamanho**: Grande (4-5 dias)  
**Prioridade**: Alta

## Contexto

Atualmente, motoristas são registrados com status `PENDING_APPROVAL`, mas não existe um fluxo administrativo para análise de documentação e aprovação. 

Necessário implementar uma **camada administrativa** onde usuários com perfil ADMIN analisam a documentação do motorista (CNH, comprovante de residência, registro criminal, etc.) e decidem sobre a ativação ou rejeição do motorista na plataforma.

## Objetivo

Implementar um fluxo completo de aprovação de motoristas que:

1. **Submissão**: Motorista recém cadastrado tem seu dossier automático criado aguardando análise
2. **Revisão**: Admin visualiza documentação pendente e analisa dados do motorista
3. **Decisão**: Admin aprova (ativa motorista) ou rejeita (com motivo) o motorista
4. **Notificação**: Motorista é notificado da decisão via email/push
5. **Auditoria**: Rastreabilidade completa da aprovação (quem, quando, motivo)

## Escopo

### 1. Novos Agregados de Domínio

#### DriverApprovalRequest (Aggregate Root)
**Localização**: `domain/entities/DriverApprovalRequest.java`

```java
public class DriverApprovalRequest {
    private UUID id;                          // Identificador único
    private UUID driverId;                    // Referência ao driver
    private TenantId tenantId;                // Multi-tenancy
    private ApprovalStatus status;            // PENDING, APPROVED, REJECTED
    private String submittedDocuments;        // JSON com lista de documentos: CNH, Comprovante, etc.
    private LocalDateTime submittedAt;        // Quando foi submetido
    private LocalDateTime reviewedAt;         // Quando foi revisado (null se pendente)
    private UUID reviewedByAdminId;           // Qual admin revisou (null se pendente)
    private String rejectionReason;           // Motivo da rejeição (null se aprovado)
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // Métodos de comportamento
    public void approve(UUID adminId);        // Admin aprova
    public void reject(UUID adminId, String reason);  // Admin rejeita com motivo
    public boolean isPending();
    public boolean isApproved();
    public boolean isRejected();
}
```

**Invariantes de Domínio**:
- Status só pode passar: PENDING → APPROVED ou PENDING → REJECTED
- Não pode mudar para APPROVED se já foi REJECTED (e vice-versa)
- `rejectionReason` é obrigatório para REJECTED
- `reviewedByAdminId` é obrigatório quando não PENDING

#### AdminUser (Value Object)
**Localização**: `domain/valueobjects/AdminUser.java`

```java
public final class AdminUser {
    private final UUID id;
    private final Email email;
    private final AdminRole role;  // SUPER_ADMIN, COMPLIANCE_OFFICER, SUPPORT_ADMIN
    private final String fullName;
    private final LocalDateTime createdAt;
    
    // Value object immutable
}
```

#### ApprovalStatus (Enum)
**Localização**: `domain/enums/ApprovalStatus.java`

```java
public enum ApprovalStatus {
    PENDING,       // Aguardando análise
    APPROVED,      // Aprovado e motorista ativo
    REJECTED       // Rejeitado
}
```

#### AdminRole (Enum)
**Localização**: `domain/enums/AdminRole.java`

```java
public enum AdminRole {
    SUPER_ADMIN,        // Acesso total
    COMPLIANCE_OFFICER, // Analisa documentação e aprova/rejeita
    SUPPORT_ADMIN       // Suporte, visualiza apenas
}
```

### 2. Casos de Uso (Use Cases)

#### 2.1 SubmitDriverApprovalUseCase
**Interface**: `application/ports/input/SubmitDriverApprovalInputPort.java`
**Implementação**: `application/usecases/approval/SubmitDriverApprovalUseCase.java`

**Entrada**: 
```java
public record SubmitDriverApprovalCommand(
    UUID driverId,
    List<String> documentUrls  // URLs dos documentos enviados
) {}
```

**Lógica**:
1. Verifica se driver existe e está em `PENDING_APPROVAL`
2. Cria novo `DriverApprovalRequest` com status `PENDING`
3. Valida documentos mínimos obrigatórios (CNH, comprovante)
4. Persiste e publica `DriverApprovalSubmittedEvent`

**Saídas**: `DriverApprovalRepositoryPort`

#### 2.2 ListPendingApprovalsUseCase
**Interface**: `application/ports/input/ListPendingApprovalsInputPort.java`
**Implementação**: `application/usecases/approval/ListPendingApprovalsUseCase.java`

**Entrada**:
```java
public record ListPendingApprovalsCommand(
    UUID adminId,
    int pageNumber,
    int pageSize
) {}
```

**Lógica**:
1. Verifica se admin existe e tem permissão (role != SUPPORT_ADMIN)
2. Busca todas as aprovações com status `PENDING` da mesma tenant
3. Retorna paginated list com dados do motorista + documentação

**Saídas**: `DriverApprovalRepositoryPort`, `AdminUserRepositoryPort`

#### 2.3 ApproveDriverUseCase
**Interface**: `application/ports/input/ApproveDriverInputPort.java`
**Implementação**: `application/usecases/approval/ApproveDriverUseCase.java`

**Entrada**:
```java
public record ApproveDriverCommand(
    UUID approvalRequestId,
    UUID adminId,
    String notes  // Observações opcionais
) {}
```

**Lógica**:
1. Valida admin (SUPER_ADMIN ou COMPLIANCE_OFFICER)
2. Carrega `DriverApprovalRequest` e verifica se está PENDING
3. Chama `approvalRequest.approve(adminId)` (domínio marca como APPROVED)
4. Carrega Driver associado e chama `driver.activate()` (muda status para ACTIVE)
5. Persiste ambos (transação)
6. Publica eventos:
   - `DriverApprovedEvent(driverId, adminId)`
   - Dispara notificação para motorista (email/push)

**Saídas**: `DriverApprovalRepositoryPort`, `DriverRepositoryPort`, `NotificationPort`, `EventDispatcherPort`

#### 2.4 RejectDriverUseCase
**Interface**: `application/ports/input/RejectDriverInputPort.java`
**Implementação**: `application/usecases/approval/RejectDriverUseCase.java`

**Entrada**:
```java
public record RejectDriverCommand(
    UUID approvalRequestId,
    UUID adminId,
    String rejectionReason,  // Obrigatório: ex. "Documentação inválida", "Histórico criminal"
    boolean permanentBan    // Se true, bloqueia driver; se false, permite resubmissão
) {}
```

**Lógica**:
1. Valida admin (SUPER_ADMIN ou COMPLIANCE_OFFICER)
2. Carrega `DriverApprovalRequest` e verifica se está PENDING
3. Chama `approvalRequest.reject(adminId, rejectionReason)`
4. Se `permanentBan=true`: carrega Driver e chama `driver.block()` (status BLOCKED)
5. Persiste
6. Publica `DriverRejectedEvent(driverId, rejectionReason, adminId)`
7. Notifica motorista sobre rejeição com motivo

**Saídas**: `DriverApprovalRepositoryPort`, `DriverRepositoryPort`, `NotificationPort`

### 3. Portas (Ports)

#### Input Ports
```
application/ports/input/
├── SubmitDriverApprovalInputPort.java
├── ListPendingApprovalsInputPort.java
├── ApproveDriverInputPort.java
└── RejectDriverInputPort.java
```

#### Output Ports
```
application/ports/output/
├── DriverApprovalRepositoryPort.java      // CRUD + query operations
├── AdminUserRepositoryPort.java           // Lookup admin por ID
├── NotificationPort.java                  // Enviar notificações (já existe)
└── EventDispatcherPort.java              // Já existe
```

### 4. Adapters (Infrastructure)

#### 4.1 JpaDriverApprovalRepositoryAdapter
**Localização**: `infrastructure/persistence/adapters/JpaDriverApprovalRepositoryAdapter.java`

**Responsabilidades**:
- JPA entity: `DriverApprovalRequestJpaEntity` mapeado para tabela `driver_approval_requests`
- Mapper: `DriverApprovalRequestMapper` (domain ↔ JPA)
- Queries: `findPendingByTenant(tenantId)`, `findByDriverId(driverId)`, `findById(id)`

**Tabela**:
```sql
CREATE TABLE driver_approval_requests (
    id UUID PRIMARY KEY,
    driver_id UUID NOT NULL,
    tenant_id UUID NOT NULL,
    status VARCHAR(20) NOT NULL,  -- PENDING, APPROVED, REJECTED
    submitted_documents JSONB NOT NULL,
    submitted_at TIMESTAMP NOT NULL,
    reviewed_at TIMESTAMP,
    reviewed_by_admin_id UUID,
    rejection_reason VARCHAR(500),
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    FOREIGN KEY (driver_id) REFERENCES drivers(id),
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    INDEX idx_status_tenant (status, tenant_id),
    INDEX idx_driver_id (driver_id)
);
```

#### 4.2 JpaAdminUserRepositoryAdapter
**Localização**: `infrastructure/persistence/adapters/JpaAdminUserRepositoryAdapter.java`

**Tabela**:
```sql
CREATE TABLE admin_users (
    id UUID PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    role VARCHAR(50) NOT NULL,  -- SUPER_ADMIN, COMPLIANCE_OFFICER, SUPPORT_ADMIN
    full_name VARCHAR(255) NOT NULL,
    tenant_id UUID NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    INDEX idx_email (email),
    INDEX idx_role_tenant (role, tenant_id)
);
```

### 5. REST API (Presentation Layer)

#### 5.1 ApprovalController
**Localização**: `presentation/controllers/ApprovalController.java`

**Endpoints**:

| Método | Path | Descrição |
|--------|------|-----------|
| GET | `/api/approvals/pending` | Lista aprovações pendentes (query params: page, size) |
| GET | `/api/approvals/{id}` | Detalha uma aprovação |
| POST | `/api/approvals/{id}/approve` | Admin aprova |
| POST | `/api/approvals/{id}/reject` | Admin rejeita |
| GET | `/api/drivers/{driverId}/approval-status` | Status da aprovação de um motorista |

**DTOs**:
```java
// Request
public record ApproveApprovalRequest(
    String notes
) {}

public record RejectApprovalRequest(
    String rejectionReason,
    boolean permanentBan
) {}

// Response
public record DriverApprovalResponse(
    UUID id,
    UUID driverId,
    String driverName,
    ApprovalStatus status,
    LocalDateTime submittedAt,
    LocalDateTime reviewedAt,
    String rejectionReason,
    AdminUserResponse reviewedBy  // null se pendente
) {}

public record AdminUserResponse(
    UUID id,
    String fullName,
    String email,
    String role
) {}
```

### 6. Events (Domain Events)

#### 6.1 DriverApprovalSubmittedEvent
```java
public record DriverApprovalSubmittedEvent(
    UUID eventId,
    LocalDateTime occurredOn,
    UUID driverId,
    UUID approvalRequestId,
    List<String> documents
) implements DomainEvent {}
```

#### 6.2 DriverApprovedEvent
```java
public record DriverApprovedEvent(
    UUID eventId,
    LocalDateTime occurredOn,
    UUID driverId,
    UUID approvalRequestId,
    UUID approvedByAdminId,
    String approverName
) implements DomainEvent {}
```

#### 6.3 DriverRejectedEvent
```java
public record DriverRejectedEvent(
    UUID eventId,
    LocalDateTime occurredOn,
    UUID driverId,
    UUID approvalRequestId,
    UUID rejectedByAdminId,
    String rejectionReason,
    boolean permanentBan
) implements DomainEvent {}
```

## Critérios de Aceite

### Fase 1: Domínio & Casos de Uso
- [ ] `DriverApprovalRequest` aggregate criado com invariantes validados
- [ ] `AdminUser`, `AdminRole`, `ApprovalStatus` value objects/enums implementados
- [ ] 4 use cases implementados com lógica de negócio correta
- [ ] Testes unitários para cada use case (mocks de portas)
- [ ] Domínio 100% framework-free (zero imports de Spring/JPA)

### Fase 2: Persistência
- [ ] `DriverApprovalRequestJpaEntity` + mapper + adapter
- [ ] `AdminUserJpaEntity` + mapper + adapter
- [ ] Migrations SQL criadas (tabelas + índices)
- [ ] Testes de integração para queries (@DataJpaTest)
- [ ] Queries otimizadas (índices corretos para filtros)

### Fase 3: REST API
- [ ] `ApprovalController` implementado com 5 endpoints
- [ ] DTOs request/response criados
- [ ] Mappers DTO ↔ Domain
- [ ] Validação de permissões (admin role checks)
- [ ] Exception handlers para casos de erro
- [ ] Tests E2E para happy path + error paths

### Fase 4: Observabilidade & Completude
- [ ] Eventos de domínio publicados via Outbox
- [ ] Logs estruturados com [APPROVAL_*] prefixes
- [ ] Notificações de motorista (email com motivo se rejeitado)
- [ ] Testes de segurança: admin com role errada tenta aprovar → 403
- [ ] Testes de transação: aproval + driver activation em mesma TX

## Fluxo de Usuário

### Fluxo Happy Path: Aprovação
```
1. Motorista registra (status: PENDING_APPROVAL)
2. Frontend submete documentação: POST /api/approvals/submit
   - Sistema cria DriverApprovalRequest (status: PENDING)
   - Publica DriverApprovalSubmittedEvent
3. Admin loga no painel
4. Admin vê lista de aprovações pendentes: GET /api/approvals/pending
5. Admin abre detalhes: GET /api/approvals/{id}
   - Vê documentos, dados do motorista
6. Admin aprova: POST /api/approvals/{id}/approve
   - Sistema valida permissão (SUPER_ADMIN ou COMPLIANCE_OFFICER)
   - DriverApprovalRequest → status APPROVED
   - Driver → status ACTIVE
   - Publica DriverApprovedEvent
   - Notifica motorista via email: "Parabéns! Sua aprovação foi confirmada"
7. Motorista pode agora aceitar viagens
```

### Fluxo Error: Rejeição
```
1-5. Mesmo que acima
6. Admin rejeita: POST /api/approvals/{id}/reject
   - Payload: { rejectionReason: "Documentação de CNH inválida", permanentBan: false }
   - DriverApprovalRequest → status REJECTED
   - Driver → status INACTIVE (ou BLOCKED se permanentBan=true)
   - Publica DriverRejectedEvent
   - Notifica motorista via email: 
     "Sua aprovação foi rejeitada. Motivo: Documentação de CNH inválida. 
      Você pode resubmeter documentação."
7. Se permanentBan=true: motorista não pode resubmeter
```

## Implementação Técnica

### Validações de Segurança
1. **AuthN/AuthZ**: Apenas usuários com role ADMIN podem acessar endpoints de aprovação
2. **Tenant Isolation**: Não ver aprovações de outra tenant
3. **Idempotência**: Aprovar 2x mesma requisição não causa duplicação
4. **Transação**: Aprovação do motorista + ativação do driver na mesma transação

### Performance
- Índices: `(status, tenant_id)` para queries de pendentes
- Batch operations: listar 50 pendentes por página
- Cache: admin roles (baixa frequência de mudança)

### Auditoria
- `DriverApprovalRequest` registra: `reviewedByAdminId`, `reviewedAt`, `rejectionReason`
- Eventos de domínio contêm todas essas informações para rastreabilidade

## Resíduos / Pontos de Melhoria Futuro
- [ ] Workflow com múltiplos níveis de aprovação (não fase 1)
- [ ] Integração com sistema de background check externo (via adapter)
- [ ] Dashboard admin com estatísticas (tempo médio aprovação, taxa rejeição)
- [ ] Email templates customizados por tenant
- [ ] Webhook para notificar motorista (além de email)

## Definição de Pronto

1. Código revisado e merge to main ✓
2. Testes passando (unit + integration + E2E): 100% ✓
3. Arquitetura hexagonal validada (ArchUnit tests) ✓
4. Documentação atualizada (README, comentários) ✓
5. Performance validada (<100ms para listar 50 pendentes) ✓
6. Nenhuma regression em tests existentes ✓

## Estimativa & Planejamento

| Fase | Atividade | Estimativa |
|------|-----------|-----------|
| 1 | Entidades de domínio + use cases | 1.5 dias |
| 2 | Persistência + migrations | 1 dia |
| 3 | REST API + testes E2E | 1 dia |
| 4 | Refinamentos + observabilidade | 0.5 dias |
| **Total** | | **4-5 dias** |

---

## Referências

- Domain-Driven Design: Eric Evans
- Hexagonal Architecture: Alistair Cockburn
- Este projeto: HIST-2026-001 (Optimistic Locking), HIST-2026-011 (Outbox Pattern)
