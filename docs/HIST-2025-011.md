> Este documento é histórico e pode conter implementações obsoletas. Consulte HIST-2026-012 para a referência atual.

# HIST-2025-011: Sistema de Notificações (Push & In-App)

**Data**: 03/01/2026  
**Versão**: 1.0  
**Status**: Em Implementação  
**Responsável**: Backend Team  
**Sprint**: 11

---

## 1. Contexto de Negócio

### 1.1. Problema
A plataforma RappiDrive necessita de comunicação em tempo real com motoristas e passageiros para:
- Informar sobre novas solicitações de viagem
- Notificar mudanças de status (aceite, início, conclusão)
- Alertar sobre pagamentos processados
- Informar sobre novas avaliações recebidas
- Comunicar promoções, alertas e atualizações importantes

Atualmente, não existe um sistema centralizado de notificações, causando:
- Falta de visibilidade sobre eventos críticos
- Experiência do usuário fragmentada
- Dificuldade em rastrear histórico de comunicações
- Impossibilidade de notificações push coordenadas

### 1.2. Objetivo
Implementar sistema robusto de notificações que suporte:
- **Push Notifications** (via Firebase Cloud Messaging - FCM)
- **In-App Notifications** (central de notificações no app)
- **Persistência** de histórico de notificações
- **Rastreamento** de leitura/visualização
- **Priorização** de notificações críticas vs informativas
- **Multi-tenancy** (isolamento por tenant)

### 1.3. Benefícios Esperados
- ✅ Redução de 60% em viagens perdidas por falta de comunicação
- ✅ Aumento de 40% na taxa de aceitação de viagens por motoristas
- ✅ Melhoria de 35% na satisfação do usuário (feedback sobre comunicação)
- ✅ Rastreabilidade completa de comunicações para auditoria
- ✅ Redução de 50% em tickets de suporte sobre "não recebi notificação"

---

## 2. Regras de Negócio

### RN-001: Tipos de Notificação
**Tipo**: Enumeração  
**Descrição**: Sistema suporta tipos específicos de notificações:
- `TRIP_REQUEST` - Nova solicitação de viagem (motorista)
- `TRIP_ACCEPTED` - Motorista aceitou viagem (passageiro)
- `TRIP_STARTED` - Viagem iniciada (passageiro)
- `TRIP_COMPLETED` - Viagem concluída (ambos)
- `TRIP_CANCELLED` - Viagem cancelada (ambos)
- `PAYMENT_PROCESSED` - Pagamento processado (passageiro)
- `PAYMENT_FAILED` - Falha no pagamento (passageiro)
- `RATING_RECEIVED` - Nova avaliação recebida (motorista ou passageiro)
- `PROMOTION` - Promoção disponível (ambos)
- `SYSTEM_ALERT` - Alerta do sistema (ambos)

**Validação**: NotificationType enum deve cobrir todos os eventos críticos.

---

### RN-002: Status de Notificação
**Tipo**: Ciclo de Vida  
**Descrição**: Notificação possui 4 estados:
1. `PENDING` - Criada, aguardando envio
2. `SENT` - Enviada com sucesso (push notification)
3. `READ` - Lida pelo usuário (in-app)
4. `FAILED` - Falha no envio

**Transições Permitidas**:
- PENDING → SENT (envio bem-sucedido)
- PENDING → FAILED (falha no envio)
- SENT → READ (usuário leu)
- FAILED → PENDING (retry manual)

**Validação**: Transições inválidas devem lançar `InvalidNotificationStatusException`.

---

### RN-003: Prioridade de Notificação
**Tipo**: Classificação  
**Descrição**: Notificações possuem prioridades:
- `HIGH` - Críticas, exigem ação imediata (TRIP_REQUEST, TRIP_CANCELLED)
- `MEDIUM` - Importantes, ação recomendada (PAYMENT_PROCESSED, RATING_RECEIVED)
- `LOW` - Informativas, sem urgência (PROMOTION, SYSTEM_ALERT)

**Comportamento**:
- HIGH: Push notification + som + vibração + in-app
- MEDIUM: Push notification + in-app
- LOW: Apenas in-app (sem push)

**Validação**: NotificationPriority enum com 3 níveis.

---

### RN-004: Conteúdo de Notificação
**Tipo**: Estrutura de Dados  
**Descrição**: Toda notificação possui:
- **Título** (obrigatório, max 100 chars)
- **Mensagem** (obrigatório, max 500 chars)
- **Dados Adicionais** (opcional, JSON Map<String, String> para deeplinks, IDs de entidades)

**Exemplos**:
```json
{
  "title": "Nova solicitação de viagem",
  "message": "Passageiro João aguarda em Av. Paulista, 1000",
  "data": {
    "tripId": "uuid-123",
    "passengerId": "uuid-456",
    "deeplink": "rappidrive://trip/uuid-123"
  }
}
```

**Validação**:
- Título e mensagem não podem ser vazios
- Título max 100 chars
- Mensagem max 500 chars
- Data deve ser JSON válido

---

### RN-005: Destinatário Único
**Tipo**: Regra de Entrega  
**Descrição**: Cada notificação é direcionada a **um único usuário** (`userId`).

**Justificativa**: Notificações são pessoais e contextuais (não broadcast).

**Para Broadcast**: Criar múltiplas notificações individuais (1 por usuário).

**Validação**: `userId` obrigatório e não nulo.

---

### RN-006: Retenção de Notificações
**Tipo**: Limpeza de Dados  
**Descrição**: Notificações antigas são retidas por período limitado:
- **Lidas**: 30 dias após leitura
- **Não lidas**: 90 dias após criação
- **Falhas**: 7 dias após falha

**Processo**: Job batch diário (`NotificationCleanupJob`) deleta registros expirados.

**Validação**: Soft-delete (campo `deletedAt`) para rastreabilidade.

---

### RN-007: Idempotência
**Tipo**: Prevenção de Duplicatas  
**Descrição**: Sistema impede envio duplicado para mesmo evento.

**Implementação**: `idempotencyKey` (UUID único por evento de negócio).

**Exemplo**:
- Evento: Trip aceito (tripId=123)
- IdempotencyKey: `trip-accepted-123`
- Se notificação com mesma key já existe → não criar nova

**Validação**: UNIQUE constraint em `idempotency_key` na tabela.

---

### RN-008: Auditoria
**Tipo**: Rastreabilidade  
**Descrição**: Notificações registram:
- `createdAt` - Quando foi criada
- `sentAt` - Quando foi enviada (push)
- `readAt` - Quando foi lida (in-app)
- `failedAt` - Quando falhou

**Relatórios**: Admin pode consultar:
- Taxa de entrega (SENT / PENDING)
- Taxa de leitura (READ / SENT)
- Tempo médio até leitura
- Falhas por tipo de notificação

---

### RN-009: Multi-Tenancy
**Tipo**: Isolamento de Dados  
**Descrição**: Notificações isoladas por tenant (`tenantId`).

**Validação**:
- Usuário só vê notificações do próprio tenant
- Queries sempre filtram por tenantId
- Índices compostos incluem tenantId

---

### RN-010: Device Token (FCM)
**Tipo**: Integração Externa  
**Descrição**: Para enviar push notifications:
- Usuário registra `deviceToken` (FCM) no login
- Tabela `user_devices` armazena múltiplos tokens por usuário (smartphone + tablet)
- Notificação envia para todos devices ativos do usuário

**Fora do Escopo MVP**: Implementação completa de FCM (apenas estrutura para futura integração).

---

## 3. Objetivos da História

### 3.1. Domain Layer
- [x] Criar `NotificationType` enum (10 tipos)
- [x] Criar `NotificationStatus` enum (PENDING, SENT, READ, FAILED)
- [x] Criar `NotificationPriority` enum (HIGH, MEDIUM, LOW)
- [x] Criar `NotificationContent` value object (title, message, data)
- [x] Criar `Notification` aggregate root (entidade imutável)
- [x] Criar exceções específicas:
  - `InvalidNotificationException`
  - `InvalidNotificationStatusException`
  - `NotificationNotFoundException`

### 3.2. Application Layer
- [x] Criar `NotificationRepositoryPort` (save, findById, findByUserId, findByUserIdAndStatus, countUnread, markAsRead, deleteOld)
- [x] Criar `NotificationServicePort` (interface para FCM - futura implementação)
- [x] Criar `SendNotificationInputPort` (SendNotificationCommand → Notification)
- [x] Criar `GetUserNotificationsInputPort` (userId, filters → List<Notification>)
- [x] Criar `MarkNotificationAsReadInputPort` (notificationId → void)
- [x] Criar `GetUnreadCountInputPort` (userId → Long)
- [x] Implementar use cases correspondentes

### 3.3. Infrastructure Layer
- [x] Criar `NotificationJpaEntity` com mapeamento JPA
- [x] Criar `SpringDataNotificationRepository` com queries customizadas
- [x] Criar `NotificationMapper` (Domain ↔ JPA)
- [x] Criar `JpaNotificationRepositoryAdapter`
- [x] Criar migration `V8__Create_notifications_table.sql`
- [x] Atualizar `UseCaseConfiguration` com beans

### 3.4. Presentation Layer
- [x] Criar `SendNotificationRequest` DTO (validação Jakarta)
- [x] Criar `NotificationResponse` DTO
- [x] Criar `NotificationListResponse` DTO (paginação)
- [x] Criar `NotificationDtoMapper`
- [x] Criar `NotificationController` com endpoints:
  - `POST /api/v1/notifications` - Enviar notificação (admin/system)
  - `GET /api/v1/notifications` - Listar notificações do usuário logado
  - `GET /api/v1/notifications/unread-count` - Contador de não lidas
  - `PATCH /api/v1/notifications/{id}/read` - Marcar como lida
  - `GET /api/v1/notifications/{id}` - Detalhes de notificação

---

## 4. Arquitetura e Design

### 4.1. Diagrama de Domínio

```
┌─────────────────────────────────────────────────────┐
│              Notification (Aggregate Root)          │
├─────────────────────────────────────────────────────┤
│ - id: NotificationId (UUID)                         │
│ - userId: UserId                                    │
│ - type: NotificationType                            │
│ - priority: NotificationPriority                    │
│ - content: NotificationContent (VO)                 │
│ - status: NotificationStatus                        │
│ - idempotencyKey: String (optional)                 │
│ - tenantId: TenantId                                │
│ - createdAt: LocalDateTime                          │
│ - sentAt: LocalDateTime (nullable)                  │
│ - readAt: LocalDateTime (nullable)                  │
│ - failedAt: LocalDateTime (nullable)                │
├─────────────────────────────────────────────────────┤
│ + markAsSent(): void                                │
│ + markAsRead(): void                                │
│ + markAsFailed(): void                              │
│ + isRead(): boolean                                 │
│ + isUnread(): boolean                               │
│ + isPending(): boolean                              │
│ + isHighPriority(): boolean                         │
└─────────────────────────────────────────────────────┘
```

### 4.2. Fluxos Principais

#### Fluxo 1: Enviar Notificação (Sistema → Usuário)
```
┌──────────┐    ┌─────────────────┐    ┌──────────────────┐    ┌──────────────┐
│ Sistema  │───>│SendNotification │───>│ Notification     │───>│  Repository  │
│ (Evento) │    │   UseCase       │    │ (Domain Entity)  │    │   (Persist)  │
└──────────┘    └─────────────────┘    └──────────────────┘    └──────────────┘
                         │
                         v
                ┌─────────────────┐
                │Notification     │
                │ServicePort      │ (FCM - futuro)
                │(Send Push)      │
                └─────────────────┘
```

**Passos**:
1. Evento de negócio ocorre (ex: viagem aceita)
2. Sistema invoca `SendNotificationUseCase`
3. Use case cria `Notification` entity com status PENDING
4. Salva no repositório
5. **[FUTURO]** Envia push via NotificationServicePort (FCM)
6. Atualiza status para SENT ou FAILED

#### Fluxo 2: Usuário Lista Notificações
```
┌──────────┐    ┌──────────────────┐    ┌──────────────┐    ┌─────────────┐
│ Usuário  │───>│GetUserNotific.   │───>│  Repository  │───>│  Response   │
│ (App)    │    │   UseCase        │    │  (Query)     │    │  (DTO List) │
└──────────┘    └──────────────────┘    └──────────────┘    └─────────────┘
```

**Passos**:
1. Usuário acessa central de notificações
2. Frontend chama `GET /api/v1/notifications?status=UNREAD&page=0&size=20`
3. Use case busca notificações filtradas por userId + tenantId
4. Retorna lista ordenada por `createdAt DESC`
5. Frontend exibe com badge de não lidas

#### Fluxo 3: Marcar Notificação como Lida
```
┌──────────┐    ┌──────────────────┐    ┌──────────────┐
│ Usuário  │───>│MarkAsRead        │───>│  Repository  │
│ (Tap)    │    │   UseCase        │    │  (Update)    │
└──────────┘    └──────────────────┘    └──────────────┘
```

**Passos**:
1. Usuário toca em notificação
2. Frontend chama `PATCH /api/v1/notifications/{id}/read`
3. Use case:
   - Busca notificação por ID
   - Valida que pertence ao usuário logado
   - Chama `notification.markAsRead()`
   - Salva com status READ e `readAt = now()`
4. Badge de não lidas é atualizado

---

## 5. Especificação de Dados

### 5.1. Tabela `notifications`

| Coluna            | Tipo                  | Constraints                  | Descrição                              |
|-------------------|-----------------------|------------------------------|----------------------------------------|
| id                | UUID                  | PRIMARY KEY                  | Identificador único                    |
| user_id           | UUID                  | NOT NULL, INDEX              | ID do destinatário                     |
| type              | VARCHAR(50)           | NOT NULL, CHECK (enum)       | Tipo de notificação                    |
| priority          | VARCHAR(20)           | NOT NULL, CHECK (enum)       | Prioridade (HIGH/MEDIUM/LOW)           |
| title             | VARCHAR(100)          | NOT NULL                     | Título da notificação                  |
| message           | VARCHAR(500)          | NOT NULL                     | Mensagem descritiva                    |
| data              | JSONB                 | NULL                         | Dados adicionais (deeplinks, IDs)      |
| status            | VARCHAR(20)           | NOT NULL, CHECK (enum)       | Status (PENDING/SENT/READ/FAILED)      |
| idempotency_key   | VARCHAR(255)          | UNIQUE, SPARSE               | Chave para evitar duplicatas           |
| tenant_id         | UUID                  | NOT NULL, INDEX              | ID do tenant (multi-tenancy)           |
| created_at        | TIMESTAMP             | NOT NULL, DEFAULT NOW()      | Data de criação                        |
| sent_at           | TIMESTAMP             | NULL                         | Data de envio push                     |
| read_at           | TIMESTAMP             | NULL                         | Data de leitura                        |
| failed_at         | TIMESTAMP             | NULL                         | Data de falha                          |
| deleted_at        | TIMESTAMP             | NULL                         | Soft-delete para cleanup               |

**Índices**:
1. `idx_notifications_user_id_status` (user_id, status) - Queries por usuário e status
2. `idx_notifications_tenant_id` (tenant_id) - Isolamento multi-tenant
3. `idx_notifications_created_at` (created_at DESC) - Ordenação temporal
4. `idx_notifications_type_tenant` (type, tenant_id) - Relatórios por tipo
5. `idx_notifications_idempotency_key` (idempotency_key) - UNIQUE para evitar duplicatas

**Constraints**:
- CHECK (type IN ('TRIP_REQUEST', 'TRIP_ACCEPTED', ...))
- CHECK (priority IN ('HIGH', 'MEDIUM', 'LOW'))
- CHECK (status IN ('PENDING', 'SENT', 'READ', 'FAILED'))
- UNIQUE (idempotency_key) WHERE idempotency_key IS NOT NULL

**Triggers**:
- `update_notifications_updated_at` - Atualiza `updated_at` em modificações

---

## 6. Critérios de Aceitação

### ✅ CA-001: Criar Notificação
**DADO** que o sistema detecta evento de negócio (ex: viagem aceita)  
**QUANDO** invoca `SendNotificationUseCase` com comando válido  
**ENTÃO** deve:
- Criar notificação com status PENDING
- Salvar no banco de dados
- Retornar entidade `Notification` com ID gerado
- Validar que userId, tipo e conteúdo são válidos

### ✅ CA-002: Listar Notificações por Usuário
**DADO** usuário autenticado com ID `user-123`  
**QUANDO** acessa `GET /api/v1/notifications`  
**ENTÃO** deve:
- Retornar apenas notificações do próprio usuário (tenant isolado)
- Ordenar por `createdAt DESC` (mais recentes primeiro)
- Suportar paginação (`page`, `size`)
- Suportar filtro por status (`?status=UNREAD`)
- Incluir total de registros e páginas

### ✅ CA-003: Marcar como Lida
**DADO** notificação com ID `notif-123` pertencente ao usuário logado  
**QUANDO** usuário chama `PATCH /api/v1/notifications/notif-123/read`  
**ENTÃO** deve:
- Atualizar status para READ
- Definir `readAt` com timestamp atual
- Retornar status 204 No Content
- Rejeitar com 404 se notificação não pertence ao usuário

### ✅ CA-004: Contar Não Lidas
**DADO** usuário com 5 notificações não lidas  
**QUANDO** acessa `GET /api/v1/notifications/unread-count`  
**ENTÃO** deve:
- Retornar `{ "count": 5 }`
- Contar apenas status PENDING e SENT (não READ)
- Filtrar por userId e tenantId

### ✅ CA-005: Idempotência
**DADO** notificação com `idempotencyKey="trip-accepted-123"` já existe  
**QUANDO** sistema tenta criar notificação com mesma chave  
**ENTÃO** deve:
- Retornar notificação existente (não criar duplicata)
- Log de warning "Duplicate notification prevented"
- Não lançar exceção

### ✅ CA-006: Validação de Conteúdo
**DADO** comando com título vazio ou mensagem >500 chars  
**QUANDO** invoca `SendNotificationUseCase`  
**ENTÃO** deve:
- Lançar `InvalidNotificationException`
- Incluir mensagem de erro descritiva
- Retornar HTTP 400 Bad Request no controller

### ✅ CA-007: Prioridade Correta
**DADO** notificação do tipo TRIP_REQUEST  
**QUANDO** criada  
**ENTÃO** deve:
- Ter prioridade HIGH automaticamente
- Validar regra: TRIP_REQUEST, TRIP_CANCELLED → HIGH
- PAYMENT_PROCESSED, RATING_RECEIVED → MEDIUM
- PROMOTION, SYSTEM_ALERT → LOW

### ✅ CA-008: Isolation Multi-Tenant
**DADO** tenant A com notificações  
**QUANDO** usuário do tenant B acessa sistema  
**ENTÃO** deve:
- Ver ZERO notificações do tenant A
- Queries sempre incluem `WHERE tenant_id = :currentTenantId`
- Índices compostos usam tenantId

---

## 7. Casos de Uso Detalhados

### UC-001: Enviar Notificação de Viagem Aceita
**Ator**: Sistema (triggered por evento de Trip)  
**Pré-condições**: Viagem foi aceita por motorista  
**Fluxo Principal**:
1. Sistema detecta evento `TripAcceptedEvent`
2. Extrai `passengerId`, `tripId`, `driverName`
3. Cria comando `SendNotificationCommand`:
   ```java
   SendNotificationCommand.builder()
       .userId(passengerId)
       .type(NotificationType.TRIP_ACCEPTED)
       .priority(NotificationPriority.HIGH)
       .title("Viagem aceita!")
       .message("Motorista " + driverName + " aceitou sua solicitação")
       .data(Map.of("tripId", tripId, "deeplink", "rappidrive://trip/" + tripId))
       .idempotencyKey("trip-accepted-" + tripId)
       .tenantId(tenantId)
       .build();
   ```
4. Invoca `sendNotificationUseCase.execute(command)`
5. Use case valida e cria `Notification` entity
6. Salva no repositório com status PENDING
7. **[FUTURO]** Envia push via FCM
8. Atualiza para SENT se sucesso

**Pós-condições**:
- Notificação salva no banco
- Passageiro vê notificação no app

---

### UC-002: Usuário Lê Notificações
**Ator**: Passageiro ou Motorista  
**Pré-condições**: Usuário autenticado  
**Fluxo Principal**:
1. Usuário abre app e acessa central de notificações
2. App chama `GET /api/v1/notifications?status=UNREAD&page=0&size=20`
3. Controller valida autenticação (extrai userId do token)
4. Invoca `getUserNotificationsUseCase.execute(userId, filters)`
5. Use case busca notificações:
   ```sql
   SELECT * FROM notifications
   WHERE user_id = :userId
     AND tenant_id = :tenantId
     AND status IN ('PENDING', 'SENT')
     AND deleted_at IS NULL
   ORDER BY created_at DESC
   LIMIT 20 OFFSET 0;
   ```
6. Mapeia para `NotificationResponse` DTOs
7. Retorna lista paginada

**Pós-condições**:
- Usuário vê lista de notificações
- Badge mostra contador de não lidas

---

### UC-003: Limpar Notificações Antigas
**Ator**: Sistema (Job batch diário)  
**Pré-condições**: Notificações antigas acumuladas  
**Fluxo Principal**:
1. Job `NotificationCleanupJob` executa às 03:00 AM
2. Busca notificações elegíveis para remoção:
   - READ + `readAt` < 30 dias atrás
   - UNREAD + `createdAt` < 90 dias atrás
   - FAILED + `failedAt` < 7 dias atrás
3. Soft-delete: `UPDATE notifications SET deleted_at = NOW() WHERE id IN (...)`
4. Log de auditoria: "Deleted X notifications"

**Pós-condições**:
- Banco mantém tamanho controlado
- Dados antigos preservados para auditoria (soft-delete)

---

## 8. Integrações Futuras (Fora do Escopo MVP)

### 8.1. Firebase Cloud Messaging (FCM)
**Objetivo**: Enviar push notifications reais para devices  
**Implementação**:
- Criar `FcmNotificationServiceAdapter` implements `NotificationServicePort`
- Integrar Firebase Admin SDK
- Registrar device tokens em `user_devices` table
- Enviar mensagens via FCM API:
  ```java
  Message message = Message.builder()
      .setToken(deviceToken)
      .setNotification(Notification.builder()
          .setTitle(notification.getTitle())
          .setBody(notification.getMessage())
          .build())
      .putAllData(notification.getData())
      .build();
  FirebaseMessaging.getInstance().send(message);
  ```

### 8.2. WebSocket para Notificações em Tempo Real
**Objetivo**: Push em tempo real via WebSocket (alternativa a polling)  
**Implementação**:
- Spring WebSocket + STOMP
- Cliente subscribe em `/topic/notifications/{userId}`
- Quando notificação criada, publish para WebSocket
- Cliente recebe e atualiza UI instantaneamente

### 8.3. Email Notifications
**Objetivo**: Enviar emails para notificações críticas  
**Implementação**:
- Criar `EmailNotificationServiceAdapter`
- Templates HTML para cada tipo de notificação
- Enviar via SendGrid/AWS SES
- Opção de usuário configurar preferências (push vs email)

### 8.4. SMS Notifications
**Objetivo**: SMS para eventos ultra-críticos (ex: cancelamento 5min antes)  
**Implementação**:
- Integrar Twilio/AWS SNS
- Custo por SMS → usar apenas para HIGH priority
- Usuário pode desabilitar SMS nas configurações

---

## 9. Riscos e Mitigações

| Risco                                    | Probabilidade | Impacto | Mitigação                                                                 |
|------------------------------------------|---------------|---------|---------------------------------------------------------------------------|
| Performance com grande volume            | Média         | Alto    | Índices otimizados, paginação obrigatória, cache de contadores           |
| Push notifications não entregues         | Alta          | Médio   | Fallback para in-app, retry logic, monitoramento de taxa de entrega      |
| Spam de notificações (UX ruim)           | Média         | Alto    | Rate limiting por tipo, agrupamento de notificações similares            |
| Crescimento descontrolado da tabela      | Alta          | Médio   | Job de cleanup diário, particionamento por data (futuro)                 |
| Custos de FCM/SMS elevados               | Média         | Médio   | Priorização rigorosa, desabilitar notificações não-críticas              |
| Notificações duplicadas                  | Média         | Médio   | Idempotency key obrigatória, UNIQUE constraint                           |
| Falha de isolamento multi-tenant         | Baixa         | Alto    | Testes de segurança, queries sempre com tenantId, índices compostos      |

---

## 10. Métricas de Sucesso

### 10.1. KPIs Técnicos
- **Taxa de Entrega**: ≥ 95% de notificações SENT vs PENDING
- **Tempo de Entrega**: Média < 3 segundos desde criação até push
- **Taxa de Leitura**: ≥ 60% de notificações lidas em 24h
- **Performance Query**: Listagem < 200ms para 100 notificações
- **Disponibilidade**: 99.5% uptime do serviço de notificações

### 10.2. KPIs de Negócio
- **Redução de Viagens Perdidas**: -60% (baseline: 15% → target: 6%)
- **Taxa de Aceitação de Viagens**: +40% (baseline: 50% → target: 70%)
- **Satisfação do Usuário**: +35% em pesquisas sobre comunicação
- **Redução de Tickets**: -50% em "não recebi notificação"

---

## 11. Checklist de Implementação

### Domain Layer
- [x] `NotificationType` enum (10 tipos)
- [x] `NotificationStatus` enum (4 estados)
- [x] `NotificationPriority` enum (3 níveis)
- [x] `NotificationContent` value object (title, message, data)
- [x] `Notification` aggregate root com métodos de comportamento
- [x] `InvalidNotificationException`
- [x] `InvalidNotificationStatusException`
- [x] `NotificationNotFoundException`

### Application Layer
- [x] `NotificationRepositoryPort` (9 métodos)
- [x] `NotificationServicePort` (interface para FCM - stub)
- [x] `SendNotificationInputPort` + `SendNotificationCommand`
- [x] `GetUserNotificationsInputPort` + filters
- [x] `MarkNotificationAsReadInputPort`
- [x] `GetUnreadCountInputPort`
- [x] `SendNotificationUseCase`
- [x] `GetUserNotificationsUseCase`
- [x] `MarkNotificationAsReadUseCase`
- [x] `GetUnreadCountUseCase`

### Infrastructure Layer
- [x] `NotificationJpaEntity` (mapeamento completo)
- [x] `SpringDataNotificationRepository` (queries customizadas)
- [x] `NotificationMapper` (Domain ↔ JPA)
- [x] `JpaNotificationRepositoryAdapter`
- [x] `V8__Create_notifications_table.sql` (migration completa)
- [x] `UseCaseConfiguration` (beans)

### Presentation Layer
- [x] `SendNotificationRequest` (validação Jakarta)
- [x] `NotificationResponse`
- [x] `NotificationListResponse` (paginação)
- [x] `UnreadCountResponse`
- [x] `NotificationDtoMapper`
- [x] `NotificationController` (5 endpoints)

### Tests
- [x] `HexagonalArchitectureTest` atualizado

---

## 12. Melhorias Futuras (Post-MVP)

1. **Agrupamento de Notificações**: "Você tem 5 novas avaliações" em vez de 5 notificações separadas
2. **Preferências de Notificação**: Usuário configura quais tipos quer receber
3. **Templates Dinâmicos**: Sistema de templates para customização por tenant
4. **A/B Testing**: Testar diferentes mensagens para otimizar engajamento
5. **Machine Learning**: Predizer melhor horário para enviar notificações (higher open rate)
6. **Rich Notifications**: Imagens, botões de ação (aceitar/recusar viagem direto na notificação)
7. **Localização**: Mensagens em múltiplos idiomas
8. **Analytics Dashboard**: Visualizar métricas de engajamento em tempo real
9. **Retry Inteligente**: Exponential backoff para falhas de envio
10. **Rate Limiting**: Limitar notificações por usuário/período (evitar spam)

---

## 13. Referências

- [Firebase Cloud Messaging Documentation](https://firebase.google.com/docs/cloud-messaging)
- [Spring WebSocket Guide](https://spring.io/guides/gs/messaging-stomp-websocket/)
- [PostgreSQL JSONB Performance](https://www.postgresql.org/docs/current/datatype-json.html)
- [Domain-Driven Design - Eric Evans](https://www.domainlanguage.com/ddd/)
- [Hexagonal Architecture - Alistair Cockburn](https://alistair.cockburn.us/hexagonal-architecture/)

---

**Fim do Documento**
