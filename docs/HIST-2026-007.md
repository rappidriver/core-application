# HIST-2026-007: Optimize Geospatial Queries with PostGIS Indexes

**Type**: Technical Story  
**Priority**: High  
**Status**: Ready for Implementation  
**Created**: 2026-01-07  
**Related**: HIST-2026-006 (Parallel Execution)

## Context

With parallel driver search implemented (HIST-2026-006), we're now executing 4 concurrent geospatial queries. While this improves throughput, **each individual query must be optimized** to maximize benefits. Currently, `findAvailableDriversNearby()` may be doing full table scans without proper spatial indexes.

**Problem**:
- Driver location queries without spatial indexes are slow (O(n) full scans)
- ST_DWithin and ST_Distance functions need GIST indexes to be efficient
- Missing composite indexes on (tenant_id, status, location)
- No query performance monitoring/logging

**Business Impact**:
- Slow driver matching affects user experience
- High database load during peak hours
- Parallel execution doesn't help if queries are sequential at DB level

## Goals

1. Add PostGIS spatial indexes (GIST) on driver location column
2. Create composite indexes for common query patterns
3. Add query performance logging with execution times
4. Validate index usage with EXPLAIN ANALYZE
5. Benchmark before/after performance improvements

## Technical Details

### Current Query Pattern

```sql
-- Current query (likely doing sequential scan)
SELECT * FROM drivers 
WHERE tenant_id = ? 
  AND status = 'ACTIVE'
  AND ST_DWithin(
    current_location::geography,
    ST_SetSRID(ST_MakePoint(?, ?), 4326)::geography,
    ? * 1000  -- radius in meters
  )
ORDER BY ST_Distance(
    current_location::geography,
    ST_SetSRID(ST_MakePoint(?, ?), 4326)::geography
  )
LIMIT 10;
```

### Proposed Optimizations

#### 1. Add Spatial Index (GIST)

**Migration**: `V14__add_spatial_indexes.sql`

```sql
-- Create GIST index for spatial queries (essential for PostGIS performance)
CREATE INDEX idx_drivers_location_gist 
ON drivers USING GIST (current_location);

-- Composite index for tenant + status + spatial
-- Note: GIST index can include non-spatial columns
CREATE INDEX idx_drivers_tenant_status_location_gist 
ON drivers USING GIST (tenant_id, status, current_location);

-- Optional: Partial index for only active drivers (smaller, faster)
CREATE INDEX idx_drivers_active_location_gist 
ON drivers USING GIST (current_location)
WHERE status = 'ACTIVE';

-- Add index on tenant_id for joins
CREATE INDEX idx_drivers_tenant_id 
ON drivers (tenant_id);
```

#### 2. Query Performance Logging

**File**: `src/main/java/com/rappidrive/infrastructure/persistence/adapters/JpaDriverGeoQueryAdapter.java`

Add execution time logging:

```java
@Override
public List<Driver> findAvailableDriversNearby(Location location, 
                                                 double radiusKm, 
                                                 TenantId tenantId) {
    long startTime = System.nanoTime();
    
    try {
        // Execute query
        List<DriverJpaEntity> entities = executeGeoQuery(location, radiusKm, tenantId);
        
        long duration = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime);
        log.debug("Geospatial query completed in {}ms for tenant={}, radius={}km, results={}", 
                  duration, tenantId.getValue(), radiusKm, entities.size());
        
        if (duration > 100) {
            log.warn("Slow geospatial query detected: {}ms (threshold: 100ms)", duration);
        }
        
        return entities.stream()
            .map(mapper::toDomain)
            .toList();
    } catch (Exception e) {
        log.error("Geospatial query failed for tenant={}, location={}", 
                  tenantId.getValue(), location, e);
        throw new DriverQueryException("Failed to query drivers", e);
    }
}
```

#### 3. Query Optimization with Native SQL

Update repository to use optimized native query:

```java
@Query(value = """
    SELECT d.* 
    FROM drivers d
    WHERE d.tenant_id = :tenantId
      AND d.status = 'ACTIVE'
      AND d.current_location IS NOT NULL
      AND ST_DWithin(
          d.current_location::geography,
          ST_SetSRID(ST_MakePoint(:longitude, :latitude), 4326)::geography,
          :radiusMeters
      )
    ORDER BY d.current_location <-> ST_SetSRID(ST_MakePoint(:longitude, :latitude), 4326)::geometry
    LIMIT 10
    """, nativeQuery = true)
List<DriverJpaEntity> findNearbyActiveDrivers(
    @Param("tenantId") UUID tenantId,
    @Param("latitude") double latitude,
    @Param("longitude") double longitude,
    @Param("radiusMeters") double radiusMeters
);
```

**Note**: `<->` operator uses KNN-GIST for ultra-fast nearest neighbor search.

#### 4. Performance Testing

**File**: `src/test/java/com/rappidrive/infrastructure/persistence/DriverGeoQueryPerformanceTest.java`

```java
@SpringBootTest
@Testcontainers
class DriverGeoQueryPerformanceTest {
    
    @Test
    void shouldQueryDriversUnder100ms() {
        // Given: 1000 drivers spread across São Paulo
        createTestDrivers(1000);
        
        Location pickupLocation = new Location(-23.550520, -46.633308);
        
        // When: Query nearby drivers
        long start = System.nanoTime();
        List<Driver> drivers = geoQueryPort.findAvailableDriversNearby(
            pickupLocation, 5.0, tenantId
        );
        long duration = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
        
        // Then: Should complete under 100ms with proper indexes
        assertThat(duration).isLessThan(100);
        assertThat(drivers).hasSizeLessThanOrEqualTo(10);
    }
    
    @Test
    void shouldValidateIndexUsage() {
        // Execute EXPLAIN ANALYZE to verify index usage
        String explainQuery = """
            EXPLAIN ANALYZE
            SELECT * FROM drivers 
            WHERE tenant_id = ? 
              AND status = 'ACTIVE'
              AND ST_DWithin(...)
            """;
        
        String plan = jdbcTemplate.queryForObject(explainQuery, String.class, ...);
        
        // Verify GIST index is being used
        assertThat(plan).contains("Index Scan using idx_drivers");
        assertThat(plan).doesNotContain("Seq Scan");
    }
}
```

## Tasks

- [ ] 1. Create migration V14 with spatial GIST indexes
- [ ] 2. Add performance logging to JpaDriverGeoQueryAdapter
- [ ] 3. Optimize native SQL query with KNN operator (<->)
- [ ] 4. Create DriverQueryException for error handling
- [ ] 5. Add DriverGeoQueryPerformanceTest with benchmarks
- [ ] 6. Run EXPLAIN ANALYZE to validate index usage
- [ ] 7. Document query performance in README (expected <100ms)
- [ ] 8. Update application.yml with SQL logging for development
- [ ] 9. Run full test suite and verify all 372 tests pass
- [ ] 10. Measure before/after performance improvement

## Acceptance Criteria

- [ ] GIST indexes created on drivers.current_location
- [ ] Composite index on (tenant_id, status, location)
- [ ] Geospatial queries complete in <100ms (with 1000+ drivers)
- [ ] EXPLAIN ANALYZE shows "Index Scan", not "Seq Scan"
- [ ] Query execution time logged at DEBUG level
- [ ] Slow query warnings (>100ms) logged at WARN level
- [ ] Performance test validates <100ms threshold
- [ ] All 372 existing tests still pass
- [ ] Documentation updated with performance characteristics

## Expected Outcomes

**Performance Improvements**:
- Single zone query: 50-200ms → <50ms (60-75% faster)
- 4 parallel zones: 50-200ms → <50ms each (still parallel)
- Database CPU usage: -40% (less sequential scans)
- Query throughput: +3-5x more queries/second

**Scalability**:
- Supports 10,000+ drivers per tenant efficiently
- Sub-100ms queries even with large datasets
- Reduced database connection pool pressure

## Risks & Mitigations

**Risk**: Index creation locks table during migration
- **Mitigation**: Use `CREATE INDEX CONCURRENTLY` (no table lock)

**Risk**: Indexes increase write overhead
- **Mitigation**: Driver location updates are infrequent, read-heavy workload

**Risk**: Index size increases database storage
- **Mitigation**: GIST indexes are ~30% overhead, acceptable for read performance

## Related Stories

- **HIST-2026-006**: Parallel Execution (completed - benefits from faster queries)
- **HIST-2026-008**: Add database connection pool monitoring (future)
- **HIST-2026-009**: Implement query result caching (future)

## References

- [PostGIS Performance Tips](https://postgis.net/workshops/postgis-intro/performance.html)
- [PostgreSQL GIST Indexes](https://www.postgresql.org/docs/current/gist.html)
- [PostGIS KNN Search](https://postgis.net/docs/geometry_distance_knn.html)
