> Este documento √© hist√≥rico e pode conter implementa√ß√µes obsoletas. Consulte HIST-2026-012 para a refer√™ncia atual.

# HIST-2025-010: Implementar Sistema de Avalia√ß√µes (Rating & Review)

**Data**: 03/01/2026  
**Status**: üöß IN PROGRESS  
**Tipo**: Feature

## Descri√ß√£o

Implementar o **sistema completo de avalia√ß√µes (ratings e reviews)** para a plataforma RappiDrive. Ap√≥s a conclus√£o de uma viagem, tanto passageiros quanto motoristas podem avaliar um ao outro, fornecendo nota de 1 a 5 estrelas e coment√°rios opcionais. Este sistema √© fundamental para manter a qualidade do servi√ßo e construir confian√ßa na plataforma.

## Contexto de Neg√≥cio

**Motiva√ß√£o**:
- Feedback bidirecional mant√©m qualidade do servi√ßo (motoristas e passageiros)
- Avalia√ß√µes ajudam usu√°rios a tomar decis√µes informadas
- Ratings baixos permitem identificar problemas e tomar a√ß√µes corretivas
- Sistema de reputa√ß√£o incentiva bom comportamento
- Essencial para MVP de plataforma ride-hailing (padr√£o da ind√∫stria)

**Regras de Neg√≥cio**:
1. ‚úÖ Avalia√ß√£o s√≥ pode ser criada para viagem COMPLETED
2. ‚úÖ Cada participante (passageiro/motorista) pode avaliar apenas UMA vez por viagem
3. ‚úÖ Rating obrigat√≥rio (1-5 estrelas), coment√°rio opcional
4. ‚úÖ Rating m√©dio do usu√°rio calculado automaticamente
5. ‚úÖ Avalia√ß√µes s√£o imut√°veis ap√≥s cria√ß√£o (n√£o podem ser editadas)
6. ‚úÖ Prazo de 7 dias para avaliar ap√≥s conclus√£o da viagem
7. ‚úÖ Coment√°rios ofensivos podem ser reportados (soft-delete)
8. ‚úÖ Motoristas veem apenas a m√©dia, n√£o avalia√ß√µes individuais
9. ‚úÖ Passageiros podem ver m√©dia e √∫ltimas 10 avalia√ß√µes do motorista

**Casos de Uso Principais**:
- Passageiro avalia motorista ap√≥s viagem
- Motorista avalia passageiro ap√≥s viagem
- Visualizar rating m√©dio de motorista
- Visualizar hist√≥rico de avalia√ß√µes do motorista
- Reportar avalia√ß√£o ofensiva (admin)

## Objetivos

### Domain Layer
1. **Rating Entity** (Aggregate Root)
   - UUID id
   - UUID tripId (refer√™ncia √† viagem)
   - UUID raterId (quem avalia - passageiro ou motorista)
   - UUID rateeId (quem √© avaliado)
   - RatingType type (DRIVER_BY_PASSENGER, PASSENGER_BY_DRIVER)
   - int score (1-5)
   - String comment (opcional, max 500 caracteres)
   - RatingStatus status (ACTIVE, REPORTED, DELETED)
   - TenantId tenantId
   - LocalDateTime createdAt

2. **Value Objects**:
   - `RatingScore`: Valida√ß√£o 1-5 estrelas
   - `RatingComment`: Valida√ß√£o comprimento e conte√∫do ofensivo b√°sico

3. **Enums**:
   - `RatingType`: DRIVER_BY_PASSENGER, PASSENGER_BY_DRIVER
   - `RatingStatus`: ACTIVE, REPORTED, DELETED

4. **Domain Services**:
   - `RatingValidationService`: Validar se pode criar avalia√ß√£o
   - `AverageRatingCalculator`: Calcular m√©dia de ratings

5. **Domain Exceptions**:
   - `InvalidRatingException`: Rating inv√°lido (fora de 1-5)
   - `DuplicateRatingException`: J√° avaliou essa viagem
   - `RatingDeadlineExpiredException`: Prazo de 7 dias expirado
   - `TripNotCompletedException`: Viagem n√£o est√° completa

### Application Layer

6. **Output Ports**:
   - `RatingRepositoryPort`:
     ```java
     Rating save(Rating rating);
     Optional<Rating> findById(UUID id);
     Optional<Rating> findByTripIdAndRaterIdAndType(UUID tripId, UUID raterId, RatingType type);
     List<Rating> findByRateeIdAndType(UUID rateeId, RatingType type, RatingStatus status);
     List<Rating> findByTripId(UUID tripId);
     double calculateAverageByRateeId(UUID rateeId, RatingType type, RatingStatus status);
     long countByRateeIdAndType(UUID rateeId, RatingType type, RatingStatus status);
     boolean existsByTripIdAndRaterIdAndType(UUID tripId, UUID raterId, RatingType type);
     List<Rating> findRecentByRateeId(UUID rateeId, RatingType type, int limit);
     ```

7. **Input Ports** (Use Cases):

   **CreateRatingInputPort**:
   ```java
   record CreateRatingCommand(
       UUID tripId,
       UUID raterId,
       UUID rateeId,
       RatingType type,
       int score,
       String comment
   ) {}
   
   Rating execute(CreateRatingCommand command);
   ```

   **GetDriverRatingSummaryInputPort**:
   ```java
   record DriverRatingSummary(
       UUID driverId,
       double averageRating,
       long totalRatings,
       Map<Integer, Long> ratingDistribution, // 1-5 stars -> count
       List<Rating> recentRatings // √∫ltimas 10
   ) {}
   
   DriverRatingSummary execute(UUID driverId);
   ```

   **GetPassengerRatingInputPort**:
   ```java
   record PassengerRatingInfo(
       UUID passengerId,
       double averageRating,
       long totalRatings
   ) {}
   
   PassengerRatingInfo execute(UUID passengerId);
   ```

   **GetTripRatingsInputPort**:
   ```java
   record TripRatingsInfo(
       UUID tripId,
       Rating passengerRating, // pode ser null
       Rating driverRating      // pode ser null
   ) {}
   
   TripRatingsInfo execute(UUID tripId);
   ```

   **ReportOffensiveRatingInputPort**:
   ```java
   record ReportRatingCommand(
       UUID ratingId,
       UUID reporterId,
       String reason
   ) {}
   
   void execute(ReportRatingCommand command);
   ```

8. **Use Cases**:
   - `CreateRatingUseCase`: 
     * Validar viagem existe e est√° COMPLETED
     * Validar n√£o existe rating duplicado
     * Validar prazo de 7 dias n√£o expirou
     * Criar e salvar rating
     * Atualizar m√©dia de rating do motorista/passageiro (cache)
   
   - `GetDriverRatingSummaryUseCase`:
     * Calcular m√©dia de ratings ativos
     * Buscar distribui√ß√£o (quantos 1‚òÖ, 2‚òÖ, etc)
     * Buscar √∫ltimas 10 avalia√ß√µes
     * Retornar resumo completo
   
   - `GetPassengerRatingUseCase`:
     * Calcular m√©dia de ratings do passageiro
     * Retornar total de avalia√ß√µes
   
   - `GetTripRatingsUseCase`:
     * Buscar rating do passageiro para a viagem
     * Buscar rating do motorista para a viagem
     * Retornar ambos
   
   - `ReportOffensiveRatingUseCase`:
     * Validar rating existe
     * Marcar como REPORTED
     * (Futuro: notificar admin)

### Infrastructure Layer

9. **JPA Entity**: `RatingJpaEntity`
   ```java
   @Entity
   @Table(name = "ratings", indexes = {
       @Index(name = "idx_ratings_trip_id", columnList = "trip_id"),
       @Index(name = "idx_ratings_ratee_type_status", columnList = "ratee_id,type,status"),
       @Index(name = "idx_ratings_tenant_id", columnList = "tenant_id")
   })
   public class RatingJpaEntity {
       @Id
       private UUID id;
       
       @Column(name = "trip_id", nullable = false)
       private UUID tripId;
       
       @Column(name = "rater_id", nullable = false)
       private UUID raterId;
       
       @Column(name = "ratee_id", nullable = false)
       private UUID rateeId;
       
       @Enumerated(EnumType.STRING)
       @Column(name = "type", nullable = false, length = 30)
       private String type; // DRIVER_BY_PASSENGER, PASSENGER_BY_DRIVER
       
       @Column(name = "score", nullable = false)
       private Integer score; // 1-5
       
       @Column(name = "comment", length = 500)
       private String comment;
       
       @Enumerated(EnumType.STRING)
       @Column(name = "status", nullable = false, length = 20)
       private String status; // ACTIVE, REPORTED, DELETED
       
       @Column(name = "tenant_id", nullable = false)
       private UUID tenantId;
       
       @Column(name = "created_at", nullable = false, updatable = false)
       private LocalDateTime createdAt;
       
       @Column(name = "updated_at")
       private LocalDateTime updatedAt;
   }
   ```

10. **Repository**: `SpringDataRatingRepository`
    ```java
    public interface SpringDataRatingRepository extends JpaRepository<RatingJpaEntity, UUID> {
        Optional<RatingJpaEntity> findByTripIdAndRaterIdAndType(UUID tripId, UUID raterId, String type);
        List<RatingJpaEntity> findByTripId(UUID tripId);
        List<RatingJpaEntity> findByRateeIdAndTypeAndStatus(UUID rateeId, String type, String status);
        boolean existsByTripIdAndRaterIdAndType(UUID tripId, UUID raterId, String type);
        
        @Query("SELECT AVG(r.score) FROM RatingJpaEntity r WHERE r.rateeId = :rateeId AND r.type = :type AND r.status = :status")
        Double calculateAverageByRateeIdAndTypeAndStatus(
            @Param("rateeId") UUID rateeId, 
            @Param("type") String type, 
            @Param("status") String status
        );
        
        @Query("SELECT COUNT(r) FROM RatingJpaEntity r WHERE r.rateeId = :rateeId AND r.type = :type AND r.status = :status")
        Long countByRateeIdAndTypeAndStatus(
            @Param("rateeId") UUID rateeId, 
            @Param("type") String type, 
            @Param("status") String status
        );
        
        @Query("SELECT r FROM RatingJpaEntity r WHERE r.rateeId = :rateeId AND r.type = :type AND r.status = 'ACTIVE' ORDER BY r.createdAt DESC")
        List<RatingJpaEntity> findRecentByRateeIdAndType(
            @Param("rateeId") UUID rateeId, 
            @Param("type") String type, 
            Pageable pageable
        );
    }
    ```

11. **Adapter**: `JpaRatingRepositoryAdapter`
    - Implementa `RatingRepositoryPort`
    - Usa `RatingMapper` para convers√µes
    - Delega para `SpringDataRatingRepository`

12. **Mapper**: `RatingMapper`
    - Manual ou MapStruct
    - Convers√£o bidirecional Rating ‚Üî RatingJpaEntity
    - Mapeia enums String ‚Üî Domain enums

13. **Migration**: `V7__Create_ratings_table.sql`
    ```sql
    CREATE TABLE ratings (
        id UUID PRIMARY KEY,
        trip_id UUID NOT NULL,
        rater_id UUID NOT NULL,
        ratee_id UUID NOT NULL,
        type VARCHAR(30) NOT NULL CHECK (type IN ('DRIVER_BY_PASSENGER', 'PASSENGER_BY_DRIVER')),
        score INTEGER NOT NULL CHECK (score >= 1 AND score <= 5),
        comment VARCHAR(500),
        status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE', 'REPORTED', 'DELETED')),
        tenant_id UUID NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP,
        
        CONSTRAINT fk_ratings_trip FOREIGN KEY (trip_id) REFERENCES trips(id),
        CONSTRAINT uq_ratings_trip_rater_type UNIQUE (trip_id, rater_id, type)
    );
    
    CREATE INDEX idx_ratings_trip_id ON ratings(trip_id);
    CREATE INDEX idx_ratings_ratee_type_status ON ratings(ratee_id, type, status);
    CREATE INDEX idx_ratings_tenant_id ON ratings(tenant_id);
    CREATE INDEX idx_ratings_created_at ON ratings(created_at);
    
    COMMENT ON TABLE ratings IS 'Avalia√ß√µes de motoristas e passageiros ap√≥s viagens';
    COMMENT ON COLUMN ratings.type IS 'DRIVER_BY_PASSENGER: passageiro avalia motorista, PASSENGER_BY_DRIVER: motorista avalia passageiro';
    COMMENT ON COLUMN ratings.score IS 'Nota de 1 a 5 estrelas';
    COMMENT ON COLUMN ratings.status IS 'ACTIVE: ativa, REPORTED: denunciada, DELETED: soft-deleted';
    ```

14. **Cache de Rating M√©dio** (opcional, para performance):
    - Adicionar colunas em `drivers` e `passengers`:
      * `average_rating DECIMAL(3,2)`
      * `total_ratings INTEGER`
    - Atualizar via trigger ou evento de dom√≠nio

### Presentation Layer

15. **DTOs**:

    **CreateRatingRequest**:
    ```java
    public record CreateRatingRequest(
        @NotNull(message = "Trip ID √© obrigat√≥rio")
        UUID tripId,
        
        @NotNull(message = "Type √© obrigat√≥rio")
        RatingTypeDto type,
        
        @NotNull(message = "Score √© obrigat√≥rio")
        @Min(value = 1, message = "Score m√≠nimo √© 1")
        @Max(value = 5, message = "Score m√°ximo √© 5")
        Integer score,
        
        @Size(max = 500, message = "Coment√°rio deve ter no m√°ximo 500 caracteres")
        String comment
    ) {}
    ```

    **RatingResponse**:
    ```java
    public record RatingResponse(
        UUID id,
        UUID tripId,
        UUID raterId,
        UUID rateeId,
        RatingTypeDto type,
        Integer score,
        String comment,
        RatingStatusDto status,
        LocalDateTime createdAt
    ) {}
    ```

    **DriverRatingSummaryResponse**:
    ```java
    public record DriverRatingSummaryResponse(
        UUID driverId,
        Double averageRating,
        Long totalRatings,
        Map<Integer, Long> ratingDistribution,
        List<RatingResponse> recentRatings
    ) {}
    ```

    **PassengerRatingInfoResponse**:
    ```java
    public record PassengerRatingInfoResponse(
        UUID passengerId,
        Double averageRating,
        Long totalRatings
    ) {}
    ```

    **TripRatingsResponse**:
    ```java
    public record TripRatingsResponse(
        UUID tripId,
        RatingResponse passengerRating,
        RatingResponse driverRating,
        Boolean canPassengerRate,
        Boolean canDriverRate
    ) {}
    ```

16. **Controller**: `RatingController`
    ```java
    @RestController
    @RequestMapping("/api/v1/ratings")
    public class RatingController {
        
        // POST /api/v1/ratings
        // Criar avalia√ß√£o (passageiro ou motorista)
        @PostMapping
        public ResponseEntity<RatingResponse> createRating(
            @Valid @RequestBody CreateRatingRequest request,
            @RequestHeader("X-User-Id") UUID userId
        );
        
        // GET /api/v1/ratings/drivers/{driverId}/summary
        // Obter resumo de avalia√ß√µes do motorista
        @GetMapping("/drivers/{driverId}/summary")
        public ResponseEntity<DriverRatingSummaryResponse> getDriverRatingSummary(
            @PathVariable UUID driverId
        );
        
        // GET /api/v1/ratings/passengers/{passengerId}
        // Obter rating do passageiro
        @GetMapping("/passengers/{passengerId}")
        public ResponseEntity<PassengerRatingInfoResponse> getPassengerRating(
            @PathVariable UUID passengerId
        );
        
        // GET /api/v1/ratings/trips/{tripId}
        // Obter avalia√ß√µes da viagem (ambas dire√ß√µes)
        @GetMapping("/trips/{tripId}")
        public ResponseEntity<TripRatingsResponse> getTripRatings(
            @PathVariable UUID tripId
        );
        
        // POST /api/v1/ratings/{ratingId}/report
        // Reportar avalia√ß√£o ofensiva
        @PostMapping("/{ratingId}/report")
        public ResponseEntity<Void> reportRating(
            @PathVariable UUID ratingId,
            @RequestBody ReportRatingRequest request,
            @RequestHeader("X-User-Id") UUID reporterId
        );
    }
    ```

17. **Mapper**: `RatingDtoMapper`
    - Convers√£o Rating ‚Üî RatingResponse
    - Convers√£o Command ‚Üî CreateRatingRequest
    - Mapeamento de enums

## Fluxo de Avalia√ß√£o

### Fluxo Normal - Passageiro Avalia Motorista:
1. Viagem √© completada (status COMPLETED)
2. App mobile exibe tela de avalia√ß√£o
3. Passageiro seleciona estrelas (1-5) e escreve coment√°rio opcional
4. Frontend chama `POST /api/v1/ratings` com:
   - tripId
   - type: DRIVER_BY_PASSENGER
   - score: 4
   - comment: "Motorista educado e dirigiu bem"
5. Backend:
   - Valida viagem existe e est√° COMPLETED
   - Valida passageiro n√£o avaliou ainda
   - Valida prazo de 7 dias n√£o expirou
   - Cria Rating
   - Atualiza m√©dia do motorista
6. Retorna RatingResponse

### Fluxo Normal - Motorista Avalia Passageiro:
1. Motorista completa viagem
2. App exibe tela de avalia√ß√£o do passageiro
3. Motorista d√° nota (1-5) e coment√°rio opcional
4. Frontend chama `POST /api/v1/ratings` com type: PASSENGER_BY_DRIVER
5. Backend processa similar ao fluxo do passageiro

### Fluxo Consulta - Ver Rating do Motorista:
1. Passageiro busca motoristas dispon√≠veis
2. Frontend exibe lista com average_rating ao lado do nome
3. Passageiro clica em "Ver avalia√ß√µes"
4. Frontend chama `GET /api/v1/ratings/drivers/{id}/summary`
5. Backend retorna:
   - M√©dia: 4.7 ‚≠ê
   - Total: 342 avalia√ß√µes
   - Distribui√ß√£o: 5‚òÖ(250), 4‚òÖ(70), 3‚òÖ(15), 2‚òÖ(5), 1‚òÖ(2)
   - √öltimas 10 avalia√ß√µes com coment√°rios

## Regras de Valida√ß√£o

### Domain Layer (Trip Completion Service):
1. ‚úÖ `canRate(Trip)`: Viagem deve estar COMPLETED
2. ‚úÖ `isWithinRatingDeadline(Trip)`: M√°ximo 7 dias ap√≥s conclus√£o
3. ‚úÖ `hasNotRatedYet(UUID tripId, UUID raterId, RatingType)`: N√£o pode avaliar 2x

### RatingScore Value Object:
1. ‚úÖ Score entre 1 e 5 (inteiro)
2. ‚úÖ N√£o aceita null

### RatingComment Value Object:
1. ‚úÖ M√°ximo 500 caracteres
2. ‚úÖ Pode ser null/vazio (opcional)
3. ‚úÖ Sanitiza√ß√£o b√°sica (remove HTML tags)

## Crit√©rios de Aceite

### Funcional:
1. ‚úÖ Passageiro consegue avaliar motorista ap√≥s viagem COMPLETED
2. ‚úÖ Motorista consegue avaliar passageiro ap√≥s viagem COMPLETED
3. ‚úÖ N√£o permite avalia√ß√£o duplicada (mesma viagem/rater/type)
4. ‚úÖ N√£o permite avaliar viagem n√£o completada
5. ‚úÖ N√£o permite avaliar ap√≥s 7 dias da conclus√£o
6. ‚úÖ Rating m√©dio do motorista √© calculado corretamente
7. ‚úÖ Endpoint de summary retorna √∫ltimas 10 avalia√ß√µes
8. ‚úÖ Endpoint de summary retorna distribui√ß√£o de ratings
9. ‚úÖ Sistema permite reportar avalia√ß√µes ofensivas

### T√©cnico:
1. ‚úÖ Todas as entidades seguem Hexagonal Architecture
2. ‚úÖ Domain layer sem depend√™ncias de frameworks
3. ‚úÖ √çndices criados para performance (ratee_id + type + status)
4. ‚úÖ Constraint UNIQUE em (trip_id, rater_id, type)
5. ‚úÖ Migration V7 executada com sucesso
6. ‚úÖ Todos os testes passam (unit√°rios e arquitetura)

### Performance:
1. ‚úÖ C√°lculo de m√©dia usa query otimizada (AVG no banco)
2. ‚úÖ √çndices adequados para queries frequentes
3. ‚úÖ Pagina√ß√£o nas √∫ltimas avalia√ß√µes (limit 10)

## Depend√™ncias

- ‚úÖ HIST-2025-003: Domain Entities (Trip, Driver, Passenger)
- ‚úÖ HIST-2025-004: Ports e Interfaces
- ‚úÖ HIST-2025-009: Trip-Payment Integration (status COMPLETED)

## Riscos e Mitiga√ß√µes

| Risco | Probabilidade | Impacto | Mitiga√ß√£o |
|-------|--------------|---------|-----------|
| Avalia√ß√µes falsas/spam | M√©dia | Alto | Validar apenas viagens reais, limite de tempo |
| Coment√°rios ofensivos | Alta | M√©dio | Sistema de report, modera√ß√£o manual |
| Performance em c√°lculo de m√©dia | Baixa | M√©dio | Cache em coluna do usu√°rio, √≠ndices otimizados |
| Mudan√ßa de rating ap√≥s cria√ß√£o | Baixa | Baixo | Ratings imut√°veis, apenas soft-delete |

## Melhorias Futuras (Fora do Escopo MVP)

- [ ] Modera√ß√£o autom√°tica de coment√°rios (ML/NLP)
- [ ] Resposta do avaliado ao coment√°rio
- [ ] Tags predefinidas (pontualidade, limpeza, dire√ß√£o)
- [ ] An√°lise de sentimento em coment√°rios
- [ ] Dashboard de ratings para motoristas
- [ ] Sistema de badges/conquistas baseado em ratings
- [ ] Notifica√ß√µes push quando recebe avalia√ß√£o
- [ ] Filtro de motoristas por rating m√≠nimo

## Testes

### Testes Unit√°rios (Domain):
- `RatingTest`: Cria√ß√£o, valida√ß√µes, regras de neg√≥cio
- `RatingScoreTest`: Valida√ß√£o 1-5, exce√ß√µes
- `RatingCommentTest`: Valida√ß√£o comprimento, sanitiza√ß√£o
- `RatingValidationServiceTest`: Regras de valida√ß√£o complexas

### Testes de Integra√ß√£o:
- `CreateRatingUseCaseTest`: Cen√°rios de sucesso e falha
- `GetDriverRatingSummaryUseCaseTest`: C√°lculo correto de m√©dia
- `JpaRatingRepositoryAdapterTest`: Persist√™ncia e queries

### Testes de Arquitetura:
- Atualizar `HexagonalArchitectureTest` com novos InputPorts

## Estimativa

- **Complexity**: M√©dia
- **Story Points**: 5
- **Tempo Estimado**: 1-2 dias

## Notas T√©cnicas

### C√°lculo de M√©dia Otimizado:
- Usar `AVG(score)` diretamente no banco (PostgreSQL)
- Evitar carregar todos os ratings na mem√≥ria
- √çndice composto: (ratee_id, type, status) para performance

### Imutabilidade:
- Ratings n√£o podem ser editados ap√≥s cria√ß√£o
- Apenas soft-delete atrav√©s de status DELETED
- Hist√≥rico preservado para auditoria

### Multi-tenancy:
- Todas as queries filtram por tenant_id
- Constraints √∫nicos consideram tenant isolation

---

**Autor**: GitHub Copilot  
**Revisado**: -  
**Aprovado**: -
