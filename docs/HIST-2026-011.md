# HIST-2026-011: Implement Outbox Event Processor (Relay)

**Data**: 10/01/2026  
**Status**: PROPOSTO  
**Tipo**: Feature / Confiabilidade  
**Tamanho**: Médio (2-3 dias)

## Contexto

HIST-2026-009 propôs o Transactional Outbox Pattern, e HIST-2026-010 garantiu conformidade arquitetural. Agora precisamos implementar o **Relay** - o mecanismo que processa eventos acumulados na tabela `outbox_events` e os despacha para subscribers.

Atualmente, eventos ficam na tabela mas ninguém os processa, tornando o padrão incompleto.

## Objetivo

Implementar `OutboxEventProcessor` agendado que:
1. Busca eventos PENDING na tabela
2. Despacha cada evento via `EventDispatcherPort`
3. Marca como PROCESSED ou FAILED com retry logic
4. Fornece observabilidade (logs estruturados com MDC/correlationId)
5. É resiliente e idempotente para execução concorrente

## Escopo

### 1. OutboxEventProcessor (Agendador)
- **Localização**: `infrastructure/messaging/OutboxEventProcessor.java`
- **Anotações**: `@Component`, `@Slf4j`, `@RequiredArgsConstructor`
- **Método**: `@Scheduled(fixedDelayString = "${outbox.processor.delay-ms:1000}")`
- **Lógica**:
  - Busca eventos PENDING com lock pessimista (`SELECT ... FOR UPDATE SKIP LOCKED`)
  - Batch processing (ex: 10-50 eventos por ciclo)
  - Para cada evento:
    - Tenta despachar via `EventDispatcherPort`
    - Se sucesso: update status PROCESSED + timestamp
    - Se falha: incrementa tentativas; se > max-retries: FAILED
  - Log estruturado com `correlationId` do evento

### 2. Melhorias no JpaOutboxRepositoryAdapter
- Método: `findPendingEvents(int maxRetries, int batchSize)`
- Query com `SELECT ... FOR UPDATE SKIP LOCKED` para evitar race condition
- Suporte a tentativas de retry

### 3. Configuração
- `application.yml`: `outbox.processor.delay-ms`, `outbox.processor.max-retries`, `outbox.processor.batch-size`
- Bean `EventDispatcherPort` (inicial: `NoOpEventDispatcher` ou `LoggingEventDispatcher`)

### 4. Observabilidade
- Logs estruturados no `OutboxEventProcessor`:
  - `[OUTBOX_START] processing=50 pending`
  - `[OUTBOX_SUCCESS] eventId=UUID type=DriverCreatedEvent attempt=1`
  - `[OUTBOX_FAILED] eventId=UUID type=DriverCreatedEvent attempts_exceeded`
- MDC com `correlationId` para rastreamento distribuído

## Critérios de Aceite

- [ ] `OutboxEventProcessor` agendado e executando
- [ ] Eventos PENDING são processados
- [ ] Estados corretos: PROCESSED, FAILED, incremento de tentativas
- [ ] Lock pessimista para evitar duplicatas
- [ ] Logs estruturados com correlationId
- [ ] Configuração via `application.yml`
- [ ] Teste de integração que insere e processa evento
- [ ] Teste que valida comportamento com falha e retry
- [ ] Idempotência comprovada (processar 2x mesmo evento é seguro)

## Implementação Técnica

### Database Schema Update
```sql
-- Se não existir, adicionar coluna de tentativas e status
ALTER TABLE outbox_events ADD COLUMN IF NOT EXISTS 
  attempt_count INT DEFAULT 0;
ALTER TABLE outbox_events ADD COLUMN IF NOT EXISTS 
  processed_at TIMESTAMP;

-- Índice para busca eficiente de PENDING
CREATE INDEX IF NOT EXISTS idx_outbox_events_status_tenant
ON outbox_events(status, tenant_id, created_at);
```

### Configuração (application.yml)
```yaml
outbox:
  processor:
    delay-ms: 1000        # Frequência de processamento
    max-retries: 3        # Max tentativas antes de marcar FAILED
    batch-size: 50        # Eventos por ciclo
    enabled: true
```

### Exemplo OutboxEventProcessor
```java
@Component
@Slf4j
@RequiredArgsConstructor
public class OutboxEventProcessor {
    private final OutboxRepositoryPort outboxRepository;
    private final EventDispatcherPort eventDispatcher;
    
    @Scheduled(fixedDelayString = "${outbox.processor.delay-ms:1000}")
    public void processOutboxEvents() {
        int batchSize = Integer.parseInt(System.getProperty("outbox.batch-size", "50"));
        List<OutboxEvent> pending = outboxRepository.findPendingEvents(batchSize);
        
        for (OutboxEvent event : pending) {
            MDC.put("correlationId", event.getCorrelationId());
            try {
                eventDispatcher.dispatch(event.getDomainEvent());
                outboxRepository.markProcessed(event.getId());
                log.info("[OUTBOX_SUCCESS] eventId={} type={}", 
                         event.getId(), event.getEventType());
            } catch (Exception e) {
                handleFailure(event, e);
            } finally {
                MDC.clear();
            }
        }
    }
    
    private void handleFailure(OutboxEvent event, Exception e) {
        outboxRepository.incrementAttempt(event.getId());
        if (event.getAttemptCount() >= 3) {
            outboxRepository.markFailed(event.getId());
            log.error("[OUTBOX_FAILED] eventId={} attempts_exceeded", event.getId(), e);
        } else {
            log.warn("[OUTBOX_RETRY] eventId={} attempt={}/3", 
                     event.getId(), event.getAttemptCount());
        }
    }
}
```

## Entregáveis

- [ ] `OutboxEventProcessor.java` com lógica de relay
- [ ] `JpaOutboxRepositoryAdapter` com métodos para encontrar, marcar processados/falhados
- [ ] Query SQL com `SELECT ... FOR UPDATE SKIP LOCKED`
- [ ] Configuração em `application.yml`
- [ ] Teste de integração completo
- [ ] Teste de idempotência
- [ ] Teste de retry behavior
- [ ] Documentação de operação (logging, monitoring)

## Notas Técnicas

- Usar `MDC` para rastreamento com `correlationId`
- Lock pessimista é essencial para evitar race conditions em execução paralela
- Idempotência é crítica: se processar 2x o mesmo evento, resultado deve ser igual
- Batch processing melhora throughput
- Considerar usar `CompletableFuture` para paralelizar dispatch (com virtual threads)

## Relacionado

- HIST-2026-009 (Outbox Pattern proposto)
- HIST-2026-010 (Conformidade arquitetural)
- Domain Events (`com.rappidrive.domain.events.*`)
- Outbox JPA Entity (`OutboxEventJpaEntity`)
