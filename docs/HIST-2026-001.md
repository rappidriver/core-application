# HIST-2026-001 ‚Äî Assign driver concurrency (Optimistic Locking + Events) ‚úÖ

## Context
Great progress: trip creation was refactored to use Optimistic Locking and domain events. The most concurrency-sensitive use case remaining is driver acceptance (`AssignDriverToTripUseCase`): multiple drivers may attempt to accept the same trip simultaneously and we must guarantee only one succeeds and subscribers (passenger notifications) are informed.

## Objective
Refactor the "assign driver to trip" flow to ensure:
- Only one driver can accept a trip (prevent overwrite via optimistic locking). ‚úÖ
- Assignments publish domain events to notify passengers. ‚úÖ
- Infrastructure exceptions (JPA optimistic lock failures) are translated to domain/application-friendly exceptions. ‚úÖ

## Tasks
1. Adapter: `JpaTripRepositoryAdapter` üîß
   - Wrap `save()` in a try-catch.
   - Catch `org.springframework.dao.OptimisticLockingFailureException` (and related variants) and rethrow `com.rappidrive.domain.exceptions.TripConcurrencyException`.
   - Rationale: the application should not leak Spring/Hibernate exceptions.

2. Domain: new exception ‚ú®
   - Add `com.rappidrive.domain.exceptions.TripConcurrencyException` extending `DomainException`.

3. Application: `AssignDriverToTripUseCase` ‚ôªÔ∏è
   - Inject `DriverRepositoryPort` and `DomainEventPublisher` (already exists).
   - Execution flow:
     - Load Trip by id (or throw `TripNotFoundException`).
     - Validate trip is pending (`trip.isPending()`) and driver exists and `driver.isAvailableForRide()`.
     - Call `trip.assignDriver(driverId)` ‚Äî domain method must set status and driver.
     - Persist driver status (mark BUSY) and save driver.
     - Persist trip: `tripRepository.save(trip)`.
     - If `TripConcurrencyException` is thrown by the adapter, catch it and throw `com.rappidrive.application.exceptions.TripAlreadyAcceptedException` with message `"Esta corrida j√° foi aceita por outro motorista"`.
     - On success publish `TripDriverAssignedEvent` with `tripId` and `driverId`.

4. Event: `TripDriverAssignedEvent` üì®
   - Add a domain event record with `eventId`, `occurredOn`, `TripId`, `DriverId`.

5. Tests üß™
   - Unit tests for `AssignDriverToTripUseCase`:
     - Happy path: driver available + trip pending ‚Üí trip saved, driver busy, event published.
     - Conflict path: simulate `TripConcurrencyException` from repository ‚Üí `TripAlreadyAcceptedException` thrown.
     - Validation path: driver not available or trip not pending ‚Üí application/domain validation exceptions.
   - Integration/smoke test: simulate two concurrent accept attempts (threaded or Testcontainers + parallel clients) to ensure only one succeeds and the other receives a friendly error.

## Acceptance Criteria ‚úÖ
- Adapter translates optimistic lock exceptions into `TripConcurrencyException`.
- `AssignDriverToTripUseCase` handles `TripConcurrencyException` and raises `TripAlreadyAcceptedException` with correct message.
- `AssignDriverToTripUseCase` publishes `TripDriverAssignedEvent` when assignment succeeds.
- Unit tests cover success, validation, and conflict paths.
- Integration test demonstrates two concurrent accept attempts result in exactly one successful assignment and a single published event.

## Implementation Notes / Tips üí°
- Use the domain event publisher already in the project: `DomainEventPublisher.instance()` or inject it from `UseCaseConfiguration`.
- Keep translations at adapter boundary: do not leak `OptimisticLockingFailureException` beyond infrastructure.
- Prefer small, focused unit tests and one integration test for concurrency using Testcontainers or in-memory concurrent threads.
- Document the behavior in CHANGELOG / release notes.

## Risks & Mitigations ‚ö†Ô∏è
- Risk: event duplication if event publishing is not transactional with DB changes. Mitigation: ensure ordering and consider outbox pattern in future if duplicates are harmful.

---

*Prepared by the team ‚Äî follow the tasks above and open PR referencing this history file and the corresponding tests.*
