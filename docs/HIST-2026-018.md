# HIST-2026-018: Tenant Context & Request-Scoped Tenant Resolution

**Data**: 15 de Janeiro de 2026  
**Tipo**: Feature - Infrastructure (Segurança Multi-tenant)  
**Prioridade**: CRÍTICA  
**Status**: Planejado  

---

## Problema

### Contexto Atual
Com a implementação do sistema Multi-tenant (HIST-2026-010 - Tenant Onboarding), o banco de dados está preparado para isolamento lógico por `tenant_id`. No entanto, **a aplicação não possui mecanismo automático para resolver e propagar o TenantId atual** durante o ciclo de vida de uma requisição HTTP.

### Riscos de Segurança
Atualmente, o isolamento de dados depende de:
1. **Programadores** lembrarem-se de adicionar `WHERE tenant_id = ?` em **todas** as queries
2. Controllers receberem `tenantId` via DTO em cada endpoint
3. UseCases validarem manualmente o `tenantId` recebido

**Problemas críticos**:
- ❌ Se um desenvolvedor esquecer a cláusula `WHERE tenant_id`, ocorre **data leak entre tenants**
- ❌ O `tenantId` pode ser **falsificado** no JSON do request (usuário do Tenant A pode enviar ID do Tenant B)
- ❌ Não há validação centralizada de que o usuário autenticado pertence ao Tenant informado
- ❌ Código duplicado e verboso em todos os controllers para extrair e validar tenant

### Exemplo do Problema (ANTES)
```java
// TripController.java - INSEGURO
@PostMapping
public ResponseEntity<TripResponse> createTrip(@RequestBody CreateTripRequest request) {
    // ⚠️ Tenant vem do JSON do cliente - pode ser falsificado!
    TenantId tenantId = request.getTenantId();
    
    // ⚠️ Sem validação se o usuário autenticado pertence a este tenant
    // ⚠️ Programador precisa lembrar de passar tenantId para TODOS os métodos
    Trip trip = createTripUseCase.execute(request.toCommand(tenantId));
    return ResponseEntity.ok(mapper.toResponse(trip));
}
```

---

## Solução: Tenant Context Pattern

### Arquitetura Proposta
Implementar o padrão **Tenant Context** para automatizar a resolução, validação e propagação do TenantId atual usando:

1. **TenantContext** (ThreadLocal): Armazena o TenantId durante o ciclo de vida da requisição
2. **TenantResolverFilter**: Intercepta requisições HTTP, resolve e valida o Tenant
3. **Hibernate Filter**: Aplica automaticamente `WHERE tenant_id = :tenantId` em queries JPA
4. **TenantAspect**: Ativa o filtro Hibernate no início de cada transação

### Fluxo de Resolução de Tenant
```
1. Cliente → HTTP Request com Header: X-Tenant-ID: uuid-tenant-a
   ↓
2. TenantResolverFilter (OncePerRequestFilter)
   - Extrai X-Tenant-ID do header
   - Valida se Tenant existe no DB (com cache)
   - Se autenticado, valida claim JWT tenant_id == X-Tenant-ID
   - Coloca no TenantContext.setTenant(tenantId)
   ↓
3. Controller
   - Lê TenantId via TenantContext.getTenant()
   - Não precisa receber tenantId via DTO
   ↓
4. UseCase
   - Recebe tenantId do Controller (TenantContext)
   ↓
5. Repository (JPA)
   - TenantAspect ativa Hibernate Filter @FilterDef
   - Query automática: SELECT * FROM trips WHERE tenant_id = :tenantId
   ↓
6. TenantResolverFilter (finally)
   - TenantContext.clear() para limpar ThreadLocal
```

### Componentes da Solução

#### 1. TenantContext (Infrastructure/Context)
```java
package com.rappidrive.infrastructure.context;

import com.rappidrive.domain.valueobjects.TenantId;

/**
 * Thread-local context para armazenar o TenantId atual durante a requisição.
 * Limpa automaticamente após o fim do ciclo de vida da requisição.
 */
public class TenantContext {
    
    private static final ThreadLocal<TenantId> CURRENT_TENANT = new ThreadLocal<>();
    
    /**
     * Define o tenant atual para a thread da requisição.
     */
    public static void setTenant(TenantId tenantId) {
        if (tenantId == null) {
            throw new IllegalArgumentException("TenantId cannot be null");
        }
        CURRENT_TENANT.set(tenantId);
    }
    
    /**
     * Retorna o tenant atual ou lança exceção se não definido.
     * @throws TenantNotSetException se nenhum tenant foi definido no contexto
     */
    public static TenantId getTenant() {
        TenantId tenantId = CURRENT_TENANT.get();
        if (tenantId == null) {
            throw new TenantNotSetException("No tenant set in current context");
        }
        return tenantId;
    }
    
    /**
     * Retorna o tenant atual ou Optional.empty() se não definido.
     * Útil para endpoints públicos onde tenant é opcional.
     */
    public static java.util.Optional<TenantId> getTenantIfPresent() {
        return java.util.Optional.ofNullable(CURRENT_TENANT.get());
    }
    
    /**
     * Limpa o tenant do contexto atual.
     * DEVE ser chamado no finally do filtro para evitar memory leaks.
     */
    public static void clear() {
        CURRENT_TENANT.remove();
    }
}
```

#### 2. TenantResolverFilter (Infrastructure/Web/Filters)
```java
package com.rappidrive.infrastructure.web.filters;

import com.rappidrive.application.ports.output.TenantRepositoryPort;
import com.rappidrive.domain.valueobjects.TenantId;
import com.rappidrive.infrastructure.context.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.annotation.Order;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Set;

/**
 * Filtro que resolve o Tenant ID a partir do header HTTP X-Tenant-ID.
 * Executa ANTES do filtro de segurança Spring Security.
 * 
 * Lógica de Resolução:
 * 1. Verifica se existe header X-Tenant-ID
 * 2. Valida se o Tenant existe no banco (cached)
 * 3. (Futuro) Valida claim tenant_id do JWT se autenticado
 * 4. Armazena no TenantContext
 * 5. Retorna 400 Bad Request se Tenant inválido/ausente em endpoints protegidos
 */
@Component
@Order(1) // Executa antes do Spring Security Filter
public class TenantResolverFilter extends OncePerRequestFilter {
    
    private static final Logger log = LoggerFactory.getLogger(TenantResolverFilter.class);
    private static final String TENANT_HEADER = "X-Tenant-ID";
    
    // Endpoints públicos que não requerem tenant
    private static final Set<String> PUBLIC_ENDPOINTS = Set.of(
        "/actuator/health",
        "/actuator/info",
        "/v3/api-docs",
        "/swagger-ui"
    );
    
    private final TenantRepositoryPort tenantRepository;
    
    public TenantResolverFilter(TenantRepositoryPort tenantRepository) {
        this.tenantRepository = tenantRepository;
    }
    
    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {
        
        String requestUri = request.getRequestURI();
        
        // Skip tenant resolution para endpoints públicos
        if (isPublicEndpoint(requestUri)) {
            filterChain.doFilter(request, response);
            return;
        }
        
        try {
            String tenantIdHeader = request.getHeader(TENANT_HEADER);
            
            if (tenantIdHeader == null || tenantIdHeader.isBlank()) {
                log.warn("Missing {} header for request: {} {}", TENANT_HEADER, request.getMethod(), requestUri);
                response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
                response.setContentType("application/json");
                response.getWriter().write(
                    "{\"error\":\"Missing required header: " + TENANT_HEADER + "\",\"status\":400}"
                );
                return;
            }
            
            // Parse e valida TenantId
            TenantId tenantId;
            try {
                tenantId = TenantId.fromString(tenantIdHeader);
            } catch (IllegalArgumentException e) {
                log.warn("Invalid {} format: {}", TENANT_HEADER, tenantIdHeader, e);
                response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
                response.setContentType("application/json");
                response.getWriter().write(
                    "{\"error\":\"Invalid Tenant ID format\",\"status\":400}"
                );
                return;
            }
            
            // Valida se o Tenant existe (TODO: adicionar cache aqui)
            boolean tenantExists = tenantRepository.existsById(tenantId);
            if (!tenantExists) {
                log.warn("Tenant not found: {}", tenantId.asString());
                response.setStatus(HttpServletResponse.SC_NOT_FOUND);
                response.setContentType("application/json");
                response.getWriter().write(
                    "{\"error\":\"Tenant not found\",\"status\":404}"
                );
                return;
            }
            
            // TODO: Validar claim tenant_id do JWT quando Security estiver implementado
            // String jwtTenantId = extractTenantFromJWT(request);
            // if (!jwtTenantId.equals(tenantId.asString())) {
            //     throw new ForbiddenException("JWT tenant mismatch");
            // }
            
            // Define o tenant no contexto
            TenantContext.setTenant(tenantId);
            log.debug("Tenant resolved: {} for request: {} {}", tenantId.asString(), request.getMethod(), requestUri);
            
            // Continua a cadeia de filtros
            filterChain.doFilter(request, response);
            
        } finally {
            // CRÍTICO: Limpa o contexto para evitar memory leaks em thread pools
            TenantContext.clear();
        }
    }
    
    private boolean isPublicEndpoint(String requestUri) {
        return PUBLIC_ENDPOINTS.stream().anyMatch(requestUri::startsWith);
    }
}
```

#### 3. Hibernate Filter Configuration (Infrastructure/Persistence/Config)
```java
package com.rappidrive.infrastructure.persistence.config;

import com.rappidrive.infrastructure.context.TenantContext;
import jakarta.persistence.EntityManager;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.hibernate.Session;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * Aspect que ativa automaticamente o filtro Hibernate de Tenant antes de cada transação.
 * Garante que todas as queries JPA incluam automaticamente WHERE tenant_id = :tenantId.
 */
@Aspect
@Component
public class TenantFilterAspect {
    
    private static final Logger log = LoggerFactory.getLogger(TenantFilterAspect.class);
    private static final String TENANT_FILTER_NAME = "tenantFilter";
    
    private final EntityManager entityManager;
    
    public TenantFilterAspect(EntityManager entityManager) {
        this.entityManager = entityManager;
    }
    
    /**
     * Ativa o filtro Hibernate antes de qualquer método de repositório JPA.
     */
    @Before("execution(* com.rappidrive.infrastructure.persistence.repositories..*(..))")
    public void enableTenantFilter() {
        TenantContext.getTenantIfPresent().ifPresent(tenantId -> {
            Session session = entityManager.unwrap(Session.class);
            org.hibernate.Filter filter = session.enableFilter(TENANT_FILTER_NAME);
            filter.setParameter("tenantId", java.util.UUID.fromString(tenantId.asString()));
            log.trace("Tenant filter enabled for tenant: {}", tenantId.asString());
        });
    }
}
```

#### 4. Anotação @FilterDef em Entidades JPA
```java
// TripJpaEntity.java - ADICIONAR ANOTAÇÃO
package com.rappidrive.infrastructure.persistence.entities;

import jakarta.persistence.*;
import org.hibernate.annotations.Filter;
import org.hibernate.annotations.FilterDef;
import org.hibernate.annotations.ParamDef;

import java.util.UUID;

@Entity
@Table(name = "trips")
@FilterDef(
    name = "tenantFilter",
    parameters = @ParamDef(name = "tenantId", type = UUID.class)
)
@Filter(
    name = "tenantFilter",
    condition = "tenant_id = :tenantId"
)
public class TripJpaEntity {
    
    @Id
    private UUID id;
    
    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
    
    // ... demais campos
}
```

#### 5. Refatoração de Controllers
**ANTES**:
```java
@PostMapping
public ResponseEntity<TripResponse> createTrip(@RequestBody CreateTripRequest request) {
    // ❌ TenantId vem do JSON - inseguro
    TenantId tenantId = request.getTenantId();
    Trip trip = createTripUseCase.execute(request.toCommand(tenantId));
    return ResponseEntity.ok(mapper.toResponse(trip));
}
```

**DEPOIS**:
```java
@PostMapping
public ResponseEntity<TripResponse> createTrip(@RequestBody CreateTripRequest request) {
    // ✅ TenantId vem do contexto seguro (validado no filtro)
    TenantId tenantId = TenantContext.getTenant();
    Trip trip = createTripUseCase.execute(request.toCommand(tenantId));
    return ResponseEntity.ok(mapper.toResponse(trip));
}
```

---

## Atividades Técnicas

### Checklist de Implementação

#### 1. Infraestrutura Base
- [ ] Criar `TenantContext.java` em `infrastructure/context/`
- [ ] Criar `TenantNotSetException.java` em `infrastructure/context/exceptions/`
- [ ] Criar `TenantResolverFilter.java` em `infrastructure/web/filters/`
- [ ] Criar `TenantFilterAspect.java` em `infrastructure/persistence/config/`

#### 2. Configuração Hibernate
- [ ] Adicionar `@FilterDef` e `@Filter` em todas as entidades sensíveis:
  - [ ] `TripJpaEntity`
  - [ ] `DriverJpaEntity`
  - [ ] `PassengerJpaEntity`
  - [ ] `VehicleJpaEntity`
  - [ ] `PaymentJpaEntity`
  - [ ] `RatingJpaEntity`
  - [ ] `NotificationJpaEntity`
  - [ ] `FareConfigurationJpaEntity`
  - [ ] `ServiceAreaJpaEntity`

#### 3. Refatoração de Controllers
- [ ] Refatorar `TripController` para usar `TenantContext.getTenant()`
- [ ] Refatorar `DriverController` para usar `TenantContext.getTenant()`
- [ ] Refatorar `PassengerController` para usar `TenantContext.getTenant()`
- [ ] Remover `tenantId` dos DTOs de Request (mover para contexto)

#### 4. Testes
- [ ] Criar `TenantContextTest` (unit)
- [ ] Criar `TenantResolverFilterTest` (integration)
- [ ] Criar `TenantFilterAspectTest` (integration)
- [ ] Atualizar E2E tests para enviar header `X-Tenant-ID`
- [ ] Testar cenário: Request sem header → 400 Bad Request
- [ ] Testar cenário: Tenant inexistente → 404 Not Found
- [ ] Testar cenário: Filtro Hibernate aplica WHERE automático

#### 5. Performance & Segurança
- [ ] Adicionar cache para `tenantRepository.existsById()` (evitar DB hit por request)
- [ ] Configurar cache: Caffeine ou Spring Cache (TTL: 5 minutos)
- [ ] Validar claim `tenant_id` do JWT quando Security for implementado
- [ ] Adicionar métricas: `tenant_resolution_time_ms`, `tenant_cache_hits`
- [ ] Adicionar logs de auditoria: tenant resolvido, tenant inválido, tenant ausente

---

## Resultado Esperado

### Estrutura de Arquivos (DEPOIS)
```
src/main/java/com/rappidrive/
└── infrastructure/
    ├── context/
    │   ├── TenantContext.java                          ✅ NOVO
    │   └── exceptions/
    │       └── TenantNotSetException.java              ✅ NOVO
    ├── web/
    │   └── filters/
    │       └── TenantResolverFilter.java               ✅ NOVO
    └── persistence/
        ├── config/
        │   └── TenantFilterAspect.java                 ✅ NOVO
        └── entities/
            ├── TripJpaEntity.java                      ✅ MODIFICADO (+@Filter)
            ├── DriverJpaEntity.java                    ✅ MODIFICADO (+@Filter)
            ├── PassengerJpaEntity.java                 ✅ MODIFICADO (+@Filter)
            └── ... (todas as entidades tenant-aware)
```

### Comportamento Esperado

#### Request Válido
```bash
curl -X POST http://localhost:8080/api/trips \
  -H "X-Tenant-ID: 550e8400-e29b-41d4-a716-446655440000" \
  -H "Content-Type: application/json" \
  -d '{
    "passengerId": "...",
    "pickupLocation": {...},
    "dropoffLocation": {...}
  }'

# ✅ Status: 201 Created
# ✅ TenantContext automaticamente populado
# ✅ Queries JPA incluem WHERE tenant_id = '550e8400-e29b-41d4-a716-446655440000'
```

#### Request Sem Header
```bash
curl -X POST http://localhost:8080/api/trips \
  -H "Content-Type: application/json" \
  -d '{...}'

# ❌ Status: 400 Bad Request
# ❌ Body: {"error": "Missing required header: X-Tenant-ID", "status": 400}
```

#### Request com Tenant Inexistente
```bash
curl -X POST http://localhost:8080/api/trips \
  -H "X-Tenant-ID: 00000000-0000-0000-0000-000000000000" \
  -H "Content-Type: application/json" \
  -d '{...}'

# ❌ Status: 404 Not Found
# ❌ Body: {"error": "Tenant not found", "status": 404}
```

### Queries Hibernate (DEPOIS)
```sql
-- Query gerada automaticamente pelo Hibernate Filter
SELECT * FROM trips 
WHERE tenant_id = '550e8400-e29b-41d4-a716-446655440000' 
  AND id = ?;

-- ✅ Isolamento automático por tenant
-- ✅ Desenvolvedor não precisa lembrar de adicionar WHERE tenant_id
```

---

## Impacto e Benefícios

### Segurança
- ✅ **Isolamento automático**: Impossível acessar dados de outro tenant por engano
- ✅ **Validação centralizada**: Header validado uma vez no filtro, não em cada controller
- ✅ **Proteção contra falsificação**: TenantId não vem do JSON do cliente
- ✅ **Auditoria**: Logs de todas as tentativas de acesso com tenant inválido

### Performance
- ✅ **Cache de validação**: `tenantRepository.existsById()` cachado (evita DB hit)
- ✅ **ThreadLocal eficiente**: Zero overhead em requisições paralelas (Virtual Threads)
- ✅ **Filtro Hibernate**: Query otimizada com índice em `tenant_id`

### Developer Experience
- ✅ **Menos código**: Controllers não precisam validar tenant manualmente
- ✅ **Menos bugs**: Impossível esquecer de adicionar `WHERE tenant_id`
- ✅ **Testes mais simples**: Apenas configurar header `X-Tenant-ID` nos testes

### Manutenibilidade
- ✅ **Centralizado**: Toda lógica de tenant em 3 classes (Context, Filter, Aspect)
- ✅ **Extensível**: Fácil adicionar validação JWT no futuro
- ✅ **Testável**: Unit tests para Context, Integration tests para Filter

---

## Próximos Passos (Após Implementação)

1. **JWT Integration** (HIST-2026-019): Validar claim `tenant_id` do token JWT
2. **Tenant Cache** (HIST-2026-020): Implementar Caffeine cache para validação de tenants
3. **Tenant Metrics** (HIST-2026-021): Adicionar métricas Prometheus para tenant resolution
4. **Row-Level Security** (HIST-2026-022): Explorar PostgreSQL RLS como alternativa ao Hibernate Filter

---

## Referências

- [Multi-Tenancy Patterns - Microsoft Azure](https://learn.microsoft.com/en-us/azure/architecture/guide/multitenant/approaches/tenancy-models)
- [Hibernate Filters Documentation](https://docs.jboss.org/hibernate/orm/6.4/userguide/html_single/Hibernate_User_Guide.html#filters)
- [ThreadLocal Best Practices](https://www.baeldung.com/java-threadlocal)
- [Spring OncePerRequestFilter](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/filter/OncePerRequestFilter.html)

---

**Aprovação Técnica**: Pendente  
**Estimativa**: 8 horas (2 sprints)  
**Risco**: Médio (mudança em componente crítico - filtros HTTP)  
**Dependências**: HIST-2026-010 (Tenant Onboarding) ✅ Concluído
