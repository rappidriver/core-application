# HIST-2026-015: Implementação Keycloak OAuth2 Resource Server

**Data**: 2026-01-20  
**Status**: ✅ Implementado  
**Tipo**: Infraestrutura / Segurança  
**Dependências**: HIST-2026-014 (Planejamento)

## Contexto

Implementação completa da integração Keycloak OAuth2 Resource Server conforme planejado na HIST-2026-014. Remove autenticação JWT manual com segredo hardcoded e implementa modelo **Zero Trust** com validação via JWK Set (chaves públicas do Keycloak).

## Objetivos

- ✅ Substituir autenticação JWT manual por OAuth2 Resource Server
- ✅ Integrar com Keycloak para validação de tokens via JWK Set
- ✅ Implementar mapeamento de roles (realm_access + resource_access)
- ✅ Criar infraestrutura de testes com Testcontainers
- ✅ Manter arquitetura hexagonal (domain layer 100% framework-free)
- ✅ Suportar multi-tenancy via Realm-per-Tenant

## Implementação

### 1. Dependências (pom.xml)

```xml
<!-- OAuth2 Resource Server - já existia -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>

<!-- Testcontainers Keycloak - NOVO -->
<dependency>
    <groupId>com.github.dasniko</groupId>
    <artifactId>testcontainers-keycloak</artifactId>
    <version>3.1.0</version>
    <scope>test</scope>
</dependency>
```

**Removido**: Nenhuma dependência manual de JWT (já usava Spring OAuth2).

### 2. KeycloakJwtAuthenticationConverter

**Arquivo**: `infrastructure/security/keycloak/KeycloakJwtAuthenticationConverter.java`

**Responsabilidade**: Converter JWT do Keycloak em `AbstractAuthenticationToken` do Spring Security.

**Lógica de Extração de Roles**:
1. **Realm Roles**: Extrai de `realm_access.roles` (roles globais do realm)
2. **Client Roles**: Extrai de `resource_access.{client-id}.roles` (roles específicas do cliente)
3. **Prefixo**: Adiciona `ROLE_` a todas as roles (padrão Spring Security)
4. **Merge**: Combina com authorities padrão (SCOPE_openid, SCOPE_profile, etc.)

**Exemplo de JWT Claims**:
```json
{
  "sub": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "preferred_username": "driver-test",
  "email": "driver@test.com",
  "realm_access": {
    "roles": ["DRIVER", "offline_access"]
  },
  "resource_access": {
    "rappidrive-api": {
      "roles": ["ROUTE_MANAGER"]
    }
  }
}
```

**Resultado**: Authorities = `[ROLE_DRIVER, ROLE_ROUTE_MANAGER, SCOPE_openid, SCOPE_profile]`

### 3. SecurityConfiguration (Refatorado)

**Arquivo**: `infrastructure/security/SecurityConfiguration.java`

**Mudanças**:
- **Removido**: `SecretKeySpec` com segredo hardcoded
- **Adicionado**: `NimbusJwtDecoder.withJwkSetUri()` apontando para Keycloak
- **Adicionado**: `@EnableMethodSecurity(prePostEnabled = true)` para `@PreAuthorize`
- **Adicionado**: Custom `jwtAuthenticationConverter()` usando `KeycloakJwtAuthenticationConverter`

**Regras de Autorização**:

| Endpoint | Acesso |
|----------|--------|
| `POST /api/v1/drivers` | Público (cadastro) |
| `POST /api/v1/passengers` | Público (cadastro) |
| `/actuator/**` | Público (monitoramento) |
| `/swagger-ui/**` | Público (documentação) |
| `/api/v1/admin/**` | `ROLE_ADMIN` |
| `/api/v1/drivers/**` | `ROLE_DRIVER` ou `ROLE_ADMIN` |
| `/api/v1/passengers/**` | `ROLE_PASSENGER` ou `ROLE_ADMIN` |
| Outros endpoints | Autenticado |

**JwtDecoder**: Valida assinatura JWT usando chaves públicas do Keycloak (endpoint JWK Set).

### 4. SpringSecurityCurrentUserAdapter (Atualizado)

**Arquivo**: `infrastructure/security/SpringSecurityCurrentUserAdapter.java`

**Mudanças**:
- `extractUserId()`: Lê claim `sub` (UUID do usuário no Keycloak)
- `extractUsername()`: Lê claim `preferred_username` (padrão Keycloak), fallback para `email`
- `extractEmail()`: **NOVO** - Lê claim `email` (padrão OIDC)
- `getCurrentUser()`: Retorna `CurrentUser` com todos os claims extraídos

**Mapeamento de Claims**:

| Claim Keycloak | Método | Tipo |
|----------------|--------|------|
| `sub` | `extractUserId()` | String (UUID) |
| `preferred_username` | `extractUsername()` | String |
| `email` | `extractEmail()` | String |
| `realm_access.roles` | Authorities | Set<String> |
| `resource_access.{client}.roles` | Authorities | Set<String> |

### 5. CurrentUserPort (Atualizado)

**Arquivo**: `application/ports/output/CurrentUserPort.java`

**Breaking Change**: Record `CurrentUser` agora inclui campo `email`:

```java
// ANTES
record CurrentUser(String userId, String username, Set<String> roles, Set<String> scopes)

// DEPOIS
record CurrentUser(String userId, String username, String email, Set<String> roles, Set<String> scopes)
```

**Novos Métodos Helper**:
- `hasRole(String role)`: Verifica se usuário tem role específica
- `hasAnyRole(String... roles)`: Verifica se usuário tem qualquer uma das roles
- `hasScope(String scope)`: Verifica se token tem scope OAuth2 específico

**Exemplo de Uso**:
```java
CurrentUser user = currentUserPort.getCurrentUser();

if (user.hasRole("DRIVER")) {
    // Lógica específica para motoristas
}

if (user.hasAnyRole("ADMIN", "SUPER_ADMIN")) {
    // Lógica para administradores
}
```

### 6. KeycloakIntegrationTestBase

**Arquivo**: `infrastructure/security/KeycloakIntegrationTestBase.java`

**Responsabilidade**: Classe base abstrata para testes E2E com Keycloak real.

**Tecnologias**:
- **Testcontainers**: Container Docker Keycloak 23.0.3
- **RestAssured**: Cliente HTTP para testes E2E
- **@DynamicPropertySource**: Override de propriedades Spring com URLs do container

**Container Keycloak**:
```java
@Container
static KeycloakContainer keycloak = new KeycloakContainer("quay.io/keycloak/keycloak:23.0.3")
    .withRealmImportFile("keycloak/rappidrive-test-realm.json")
    .withReuse(true); // Container reusado entre testes para velocidade
```

**Métodos Utilitários**:

| Método | Descrição |
|--------|-----------|
| `getDriverToken()` | Token JWT para usuário `driver-test` |
| `getPassengerToken()` | Token JWT para usuário `passenger-test` |
| `getAdminToken()` | Token JWT para usuário `admin-test` |
| `getAccessToken(user, pwd)` | OAuth2 Password Grant genérico |
| `getRefreshToken(user, pwd)` | Obtém refresh token |
| `refreshAccessToken(refreshToken)` | Renova access token |
| `decodeJwt(token)` | Decodifica JWT para inspeção de claims |

**Fluxo OAuth2 Password Grant** (apenas para testes):
```http
POST /realms/rappidrive-test/protocol/openid-connect/token
Content-Type: application/x-www-form-urlencoded

grant_type=password
&client_id=rappidrive-api
&client_secret=test-secret
&username=driver-test
&password=driver123
&scope=openid profile email
```

**Resposta**:
```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 300
}
```

### 7. rappidrive-test-realm.json

**Arquivo**: `src/test/resources/keycloak/rappidrive-test-realm.json`

**Conteúdo**: Exportação completa de realm Keycloak para testes.

**Configuração**:

**Realm**: `rappidrive-test`
- SSL Required: `none` (apenas para ambiente local)
- Direct Access Grants: `enabled` (permite password grant para testes)

**Client**: `rappidrive-api`
- Client ID: `rappidrive-api`
- Client Protocol: `openid-connect`
- Access Type: `confidential`
- Secret: `test-secret`
- Standard Flow: `enabled`
- Direct Access Grants: `enabled`
- Valid Redirect URIs: `http://localhost:*`, `http://127.0.0.1:*`

**Realm Roles**:
- `DRIVER`: Motoristas
- `PASSENGER`: Passageiros
- `ADMIN`: Administradores

**Client Roles** (rappidrive-api):
- `SUPER_ADMIN`: Super administrador
- `COMPLIANCE_OFFICER`: Oficial de compliance
- `SUPPORT_ADMIN`: Administrador de suporte

**Usuários de Teste**:

| Username | Password | Email | Roles | Attributes |
|----------|----------|-------|-------|-----------|
| `driver-test` | `driver123` | driver@test.com | DRIVER | cpf, phone, licenseNumber |
| `passenger-test` | `passenger123` | passenger@test.com | PASSENGER | cpf, phone |
| `admin-test` | `admin123` | admin@test.com | ADMIN, SUPER_ADMIN | - |

**Protocol Mappers**:
- **realm roles**: Mapeia `realm_access.roles` no JWT
- **client roles**: Mapeia `resource_access.{client-id}.roles` no JWT
- **username**: Mapeia `preferred_username`
- **email**: Mapeia `email`

### 8. KeycloakAuthenticationE2ETest

**Arquivo**: `e2e/security/KeycloakAuthenticationE2ETest.java`

**Testes Implementados**:

| Teste | Descrição |
|-------|-----------|
| `shouldObtainDriverTokenFromKeycloak()` | Valida obtenção de token para motorista |
| `shouldObtainPassengerTokenFromKeycloak()` | Valida obtenção de token para passageiro |
| `shouldObtainAdminTokenFromKeycloak()` | Valida obtenção de token para admin |
| `shouldAccessPublicEndpointWithoutToken()` | Endpoints públicos acessíveis sem autenticação |
| `shouldRejectRequestWithoutToken()` | Endpoints protegidos rejeitam requisições sem token |
| `shouldAccessDriverEndpointWithDriverToken()` | Token de motorista acessa endpoints de motorista |
| `shouldRejectDriverEndpointWithPassengerToken()` | Token de passageiro NÃO acessa endpoints de motorista |
| `shouldAccessAdminEndpointWithAdminToken()` | Token de admin acessa endpoints de admin |
| `shouldRejectAdminEndpointWithDriverToken()` | Token de motorista NÃO acessa endpoints de admin |
| `shouldRefreshTokenSuccessfully()` | Fluxo de refresh token funciona |
| `shouldRejectInvalidToken()` | Tokens inválidos são rejeitados |
| `shouldRejectExpiredToken()` | Tokens expirados são rejeitados |

**Exemplo de Teste**:
```java
@Test
void shouldAccessDriverEndpointWithDriverToken() {
    String token = getDriverToken();
    
    given()
        .header("Authorization", "Bearer " + token)
        .when()
        .get("/drivers/available")
        .then()
        .statusCode(anyOf(is(200), is(404)));
}
```

### 9. Configuração Spring (application.yml)

**Arquivo**: `src/main/resources/application.yml`

```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${KEYCLOAK_ISSUER_URI:http://localhost:8180/realms/rappidrive-test}
          jwk-set-uri: ${KEYCLOAK_JWK_SET_URI:http://localhost:8180/realms/rappidrive-test/protocol/openid-connect/certs}

keycloak:
  auth-server-url: ${KEYCLOAK_SERVER_URL:http://localhost:8180}
  realm: ${KEYCLOAK_REALM:rappidrive-test}
  resource: ${KEYCLOAK_CLIENT_ID:rappidrive-api}
  credentials:
    secret: ${KEYCLOAK_CLIENT_SECRET:test-secret}
```

**Variáveis de Ambiente** (produção):
- `KEYCLOAK_ISSUER_URI`: URL completa do issuer (ex: https://auth.rappidrive.com/realms/tenant-abc)
- `KEYCLOAK_JWK_SET_URI`: URL do JWK Set (ex: https://auth.rappidrive.com/realms/tenant-abc/protocol/openid-connect/certs)
- `KEYCLOAK_SERVER_URL`: URL base do Keycloak
- `KEYCLOAK_REALM`: Nome do realm (multi-tenancy: um realm por tenant)
- `KEYCLOAK_CLIENT_ID`: ID do cliente OAuth2
- `KEYCLOAK_CLIENT_SECRET`: Segredo do cliente

### 10. Configuração Testes E2E (application-e2e.yml)

**Arquivo**: `src/test/resources/application-e2e.yml`

```yaml
rappidrive:
  security:
    enabled: true  # Segurança HABILITADA em E2E

spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8180/realms/rappidrive-test
          jwk-set-uri: http://localhost:8180/realms/rappidrive-test/protocol/openid-connect/certs

keycloak:
  auth-server-url: http://localhost:8180
  realm: rappidrive-test
  resource: rappidrive-api
  credentials:
    secret: test-secret
  token-endpoint: http://localhost:8180/realms/rappidrive-test/protocol/openid-connect/token
  client-id: rappidrive-api
```

**Nota**: Estas propriedades são **sobrescritas** por `@DynamicPropertySource` no `KeycloakIntegrationTestBase`, que injeta URLs reais do container Testcontainers.

### 11. Docker Compose (Keycloak para Desenvolvimento Local)

**Arquivo**: `docker-compose.yml`

```yaml
keycloak:
  image: quay.io/keycloak/keycloak:23.0.3
  container_name: rappidrive-keycloak
  environment:
    KEYCLOAK_ADMIN: admin
    KEYCLOAK_ADMIN_PASSWORD: admin
    KC_DB: postgres
    KC_DB_URL: jdbc:postgresql://postgres:5432/rappidrive_dev
    KC_DB_USERNAME: rappidrive
    KC_DB_PASSWORD: rappidrive_dev_password
    KC_HTTP_PORT: 8180
    KC_HOSTNAME_STRICT: false
    KC_HOSTNAME_STRICT_HTTPS: false
    KC_HTTP_ENABLED: true
    KC_HEALTH_ENABLED: true
    KC_METRICS_ENABLED: true
  command:
    - start-dev
    - --import-realm
  volumes:
    - keycloak_data:/opt/keycloak/data
    - ./src/test/resources/keycloak/rappidrive-test-realm.json:/opt/keycloak/data/import/rappidrive-test-realm.json:ro
  ports:
    - "8180:8180"
  networks:
    - rappidrive-network
  depends_on:
    postgres:
      condition: service_healthy
  healthcheck:
    test: ["CMD-SHELL", "exec 3<>/dev/tcp/localhost/8180 && echo -e 'GET /health/ready HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n' >&3 && cat <&3 | grep -q '200 OK'"]
    interval: 10s
    timeout: 5s
    retries: 10
    start_period: 60s
```

**Características**:
- Keycloak compartilha banco PostgreSQL com a aplicação
- Porta: `8180` (evita conflito com aplicação Spring na 8080)
- Console Admin: http://localhost:8180 (admin / admin)
- Auto-import do realm `rappidrive-test` na inicialização
- Health check para garantir disponibilidade antes de testes

## Arquitetura Hexagonal Preservada

### Domain Layer (100% Framework-Free)

**Sem mudanças**. Domain continua completamente isolado:
- `domain/entities/`: Nenhuma anotação Spring/JPA
- `domain/valueobjects/`: Imutáveis e framework-free
- `domain/services/`: Lógica de negócio pura

### Application Layer

**Mudança mínima**:
- `CurrentUserPort` interface atualizada (adição do campo `email`)
- Use cases continuam dependendo apenas de `CurrentUserPort` (abstração)
- **Nenhum use case conhece Keycloak ou Spring Security**

### Infrastructure Layer

**Todas as mudanças concentradas aqui**:
- `KeycloakJwtAuthenticationConverter`: Adapter Keycloak → Spring Security
- `SecurityConfiguration`: Configuração OAuth2 Resource Server
- `SpringSecurityCurrentUserAdapter`: Implementação de `CurrentUserPort` usando Keycloak JWT
- `KeycloakIntegrationTestBase`: Infraestrutura de testes

### Fluxo de Dependências (Preservado)

```
┌─────────────────────────────────────────────────────┐
│ Presentation (REST Controllers)                     │
│ - Endpoints protegidos por @PreAuthorize           │
└─────────────────────┬───────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────┐
│ Application (Use Cases)                             │
│ - Dependem de CurrentUserPort (abstração)          │
│ - NÃO conhecem Keycloak/Spring Security            │
└─────────────────────┬───────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────┐
│ Domain (Entities, Value Objects)                    │
│ - 100% framework-free                               │
│ - Nenhuma mudança nesta camada                      │
└─────────────────────────────────────────────────────┘
                      ▲
                      │
┌─────────────────────┴───────────────────────────────┐
│ Infrastructure (Adapters)                           │
│ - SpringSecurityCurrentUserAdapter                  │
│   (implementa CurrentUserPort)                      │
│ - KeycloakJwtAuthenticationConverter                │
│   (converte JWT → Authentication)                   │
│ - SecurityConfiguration                             │
│   (OAuth2 Resource Server setup)                    │
└─────────────────────────────────────────────────────┘
```

## Segurança Zero Trust

### Princípios Implementados

1. **Never Trust, Always Verify**:
   - Todos os endpoints autenticados (exceto cadastro e monitoramento)
   - Cada requisição validada via Keycloak JWK Set
   - Sem cache de credenciais

2. **Least Privilege**:
   - Roles granulares (DRIVER, PASSENGER, ADMIN)
   - Separação de client roles (SUPER_ADMIN, COMPLIANCE_OFFICER, etc.)
   - Endpoints segregados por role

3. **Explicit Security**:
   - `SecurityConfiguration` define regras explícitas por endpoint
   - `@EnableMethodSecurity` permite `@PreAuthorize` em métodos
   - Nenhum endpoint aberto por padrão

4. **Defense in Depth**:
   - Validação JWT na camada de infraestrutura (Spring Security)
   - Verificação de roles em controllers
   - Possibilidade de validação adicional em use cases via `CurrentUserPort`

### Validação de Token

```
┌─────────────────────────────────────────────────────────────┐
│ Cliente (Frontend / App Mobile)                             │
│ Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6...       │
└─────────────────────┬───────────────────────────────────────┘
                      │ 1. Requisição HTTP com JWT
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ Spring Security Filter Chain                                │
│ - BearerTokenAuthenticationFilter                           │
└─────────────────────┬───────────────────────────────────────┘
                      │ 2. Extrai JWT do header
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ NimbusJwtDecoder                                            │
│ - Valida assinatura usando chaves públicas do Keycloak     │
│ - Valida issuer (iss claim)                                │
│ - Valida expiração (exp claim)                             │
└─────────────────────┬───────────────────────────────────────┘
                      │ 3. JWT válido
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ KeycloakJwtAuthenticationConverter                          │
│ - Extrai realm_access.roles                                │
│ - Extrai resource_access.{client}.roles                    │
│ - Adiciona prefixo ROLE_                                   │
└─────────────────────┬───────────────────────────────────────┘
                      │ 4. JwtAuthenticationToken
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ AuthorizationFilter                                         │
│ - Verifica se usuário tem roles necessárias                │
│ - Aplica regras de SecurityConfiguration                   │
└─────────────────────┬───────────────────────────────────────┘
                      │ 5. Autorizado
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ Controller / Use Case                                       │
│ - Acessa CurrentUserPort.getCurrentUser()                  │
│ - Processa lógica de negócio                               │
└─────────────────────────────────────────────────────────────┘
```

## Multi-Tenancy via Realm-per-Tenant

### Modelo Implementado

Cada **tenant** (empresa usando a plataforma) tem seu próprio **realm Keycloak**.

**Exemplo**:
- Tenant: "UberSP" → Realm: `rappidrive-ubersp`
- Tenant: "99Taxi" → Realm: `rappidrive-99taxi`
- Tenant: "Test" → Realm: `rappidrive-test` (usado nos testes)

### Isolamento de Dados

```yaml
# application.yml - Configuração dinâmica por tenant
keycloak:
  realm: ${KEYCLOAK_REALM:rappidrive-test}
```

**Fluxo de Multi-Tenancy**:

1. **Frontend determina tenant**:
   - Subdomínio: `ubersp.rappidrive.com` → tenant = `ubersp`
   - Custom header: `X-Tenant-Id: ubersp`

2. **Frontend autentica no realm correto**:
   - Redireciona para: `https://auth.rappidrive.com/realms/rappidrive-ubersp`
   - Obtém JWT com `iss: https://auth.rappidrive.com/realms/rappidrive-ubersp`

3. **Backend valida contra realm correto**:
   - Variável de ambiente: `KEYCLOAK_REALM=rappidrive-ubersp`
   - Issuer URI: `https://auth.rappidrive.com/realms/rappidrive-ubersp`
   - JWK Set URI: `https://auth.rappidrive.com/realms/rappidrive-ubersp/protocol/openid-connect/certs`

4. **Dados isolados**:
   - Cada realm tem seus próprios usuários
   - Roles independentes por realm
   - JWT de um realm NÃO funciona em outro realm

### Configuração por Ambiente

| Ambiente | Keycloak URL | Realm | Descrição |
|----------|--------------|-------|-----------|
| **Local** | http://localhost:8180 | rappidrive-test | Desenvolvimento local |
| **E2E Tests** | Testcontainers (porta dinâmica) | rappidrive-test | Testes automatizados |
| **Staging** | https://auth-staging.rappidrive.com | rappidrive-{tenant} | Testes pré-produção |
| **Production** | https://auth.rappidrive.com | rappidrive-{tenant} | Produção |

## Como Usar

### 1. Iniciar Keycloak Localmente

```bash
# Inicia todos os serviços (PostgreSQL, Keycloak, Zipkin, Prometheus)
docker-compose up -d

# Aguardar Keycloak ficar pronto (pode levar 60s)
docker-compose logs -f keycloak

# Verificar saúde
curl http://localhost:8180/health/ready
```

**Acesso Admin**:
- URL: http://localhost:8180
- Usuário: `admin`
- Senha: `admin`

### 2. Testar Autenticação Manual (via cURL)

```bash
# 1. Obter token JWT (Password Grant)
curl -X POST http://localhost:8180/realms/rappidrive-test/protocol/openid-connect/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=password" \
  -d "client_id=rappidrive-api" \
  -d "client_secret=test-secret" \
  -d "username=driver-test" \
  -d "password=driver123" \
  -d "scope=openid profile email"

# Resposta (extrair access_token):
# {
#   "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
#   "token_type": "Bearer",
#   "expires_in": 300
# }

# 2. Chamar endpoint protegido
export TOKEN="eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..."

curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:8080/api/v1/drivers/available
```

### 3. Executar Testes E2E

```bash
# Testes automatizados com Testcontainers (inicializa Keycloak automaticamente)
mvn test -Dtest=KeycloakAuthenticationE2ETest

# Todos os testes E2E
mvn verify -Pintegration-tests
```

**Características dos Testes**:
- Container Keycloak iniciado automaticamente via Testcontainers
- Realm `rappidrive-test` importado na inicialização
- Tokens obtidos programaticamente via OAuth2 Password Grant
- RestAssured configurado automaticamente com baseURI/port
- Container reusado entre testes (`withReuse(true)`) para velocidade

### 4. Escrever Novos Testes E2E com Keycloak

```java
@SpringBootTest(webEnvironment = RANDOM_PORT)
@ActiveProfiles("e2e")
class MyFeatureE2ETest extends KeycloakIntegrationTestBase {

    @Test
    void shouldCreateTripAsDriver() {
        // 1. Obter token de motorista
        String driverToken = getDriverToken();
        
        // 2. Criar payload
        var createTripRequest = new CreateTripRequest(
            "Rua A, 123",
            "Rua B, 456"
        );
        
        // 3. Chamar endpoint autenticado
        given()
            .header("Authorization", "Bearer " + driverToken)
            .contentType(ContentType.JSON)
            .body(createTripRequest)
            .when()
            .post("/trips")
            .then()
            .statusCode(201)
            .body("id", notNullValue())
            .body("status", equalTo("PENDING"));
    }
    
    @Test
    void shouldRejectTripCreationForPassenger() {
        String passengerToken = getPassengerToken();
        
        given()
            .header("Authorization", "Bearer " + passengerToken)
            .when()
            .post("/trips")
            .then()
            .statusCode(403); // Forbidden
    }
}
```

### 5. Adicionar Novos Usuários de Teste

**Opção 1: Via Keycloak Admin Console**
1. Acessar http://localhost:8180
2. Login: admin / admin
3. Selecionar realm `rappidrive-test`
4. Users → Add User
5. Atribuir roles em Role Mappings

**Opção 2: Exportar realm atualizado**
```bash
# Exportar realm atualizado
docker exec rappidrive-keycloak /opt/keycloak/bin/kc.sh export \
  --realm rappidrive-test \
  --file /tmp/realm-export.json \
  --users realm_file

# Copiar para projeto
docker cp rappidrive-keycloak:/tmp/realm-export.json \
  ./src/test/resources/keycloak/rappidrive-test-realm.json
```

## Testes Realizados

### Testes Unitários (Mock-based)

**Não foram alterados** - Use cases continuam testando com mock de `CurrentUserPort`:

```java
@Test
void shouldGetCurrentDriverDetails() {
    // Arrange
    CurrentUser mockUser = new CurrentUser(
        "driver-123",
        "john-driver",
        "john@driver.com",  // Campo email adicionado
        Set.of("DRIVER"),
        Set.of("SCOPE_openid")
    );
    when(currentUserPort.getCurrentUser()).thenReturn(Optional.of(mockUser));
    
    // Act & Assert
    Driver driver = getDriverDetailsUseCase.execute();
    assertThat(driver.getId()).isEqualTo("driver-123");
}
```

### Testes de Integração (Com Keycloak Real)

**KeycloakAuthenticationE2ETest**:
- ✅ `shouldObtainDriverTokenFromKeycloak()`
- ✅ `shouldObtainPassengerTokenFromKeycloak()`
- ✅ `shouldObtainAdminTokenFromKeycloak()`
- ✅ `shouldAccessPublicEndpointWithoutToken()`
- ✅ `shouldRejectRequestWithoutToken()`
- ✅ `shouldAccessDriverEndpointWithDriverToken()`
- ✅ `shouldRejectDriverEndpointWithPassengerToken()`
- ✅ `shouldAccessAdminEndpointWithAdminToken()`
- ✅ `shouldRejectAdminEndpointWithDriverToken()`
- ✅ `shouldRefreshTokenSuccessfully()`
- ✅ `shouldRejectInvalidToken()`
- ✅ `shouldRejectExpiredToken()`

**Tempo de Execução**:
- Primeira execução: ~60s (download de imagem Keycloak + startup)
- Execuções subsequentes: ~10s (container reusado)

## Breaking Changes

### CurrentUser Record

**Antes**:
```java
record CurrentUser(String userId, String username, Set<String> roles, Set<String> scopes)
```

**Depois**:
```java
record CurrentUser(String userId, String username, String email, Set<String> roles, Set<String> scopes)
```

**Impacto**:
- Código que cria instâncias de `CurrentUser` precisa passar o campo `email`
- **Análise realizada**: Apenas `SpringSecurityCurrentUserAdapter` cria `CurrentUser` (já atualizado)
- Testes que mockam `CurrentUserPort.getCurrentUser()` precisam incluir `email`

**Migração**:
```java
// ANTES
when(currentUserPort.getCurrentUser()).thenReturn(
    Optional.of(new CurrentUser("user-123", "john", Set.of("DRIVER"), Set.of()))
);

// DEPOIS
when(currentUserPort.getCurrentUser()).thenReturn(
    Optional.of(new CurrentUser("user-123", "john", "john@test.com", Set.of("DRIVER"), Set.of()))
);
```

## Configuração de Produção

### Variáveis de Ambiente

```bash
# Keycloak
KEYCLOAK_SERVER_URL=https://auth.rappidrive.com
KEYCLOAK_REALM=rappidrive-{tenant-name}
KEYCLOAK_CLIENT_ID=rappidrive-api
KEYCLOAK_CLIENT_SECRET={secret-from-vault}

# OAuth2 Resource Server
KEYCLOAK_ISSUER_URI=https://auth.rappidrive.com/realms/rappidrive-{tenant-name}
KEYCLOAK_JWK_SET_URI=https://auth.rappidrive.com/realms/rappidrive-{tenant-name}/protocol/openid-connect/certs
```

### Secrets Management

**NÃO commitar** secrets no código:
- ✅ Usar variáveis de ambiente
- ✅ Vault (HashiCorp Vault, AWS Secrets Manager, etc.)
- ✅ Kubernetes Secrets
- ❌ Hardcoded no `application.yml`

### Multi-Tenancy Dinâmico

Para suportar múltiplos tenants dinamicamente:

1. **Frontend determina tenant** via subdomínio ou header
2. **API recebe tenant ID** no header `X-Tenant-Id`
3. **Configurar JwtDecoder dinâmico** por tenant:

```java
@Bean
public JwtDecoder jwtDecoder() {
    return new TenantAwareJwtDecoder(keycloakConfigRepository);
}
```

4. **Validar token contra realm correto**:
```java
String tenantId = request.getHeader("X-Tenant-Id");
String issuerUri = keycloakConfigRepository.getIssuerUri(tenantId);
NimbusJwtDecoder decoder = NimbusJwtDecoder.withIssuerLocation(issuerUri).build();
```

## Próximos Passos

1. **Implementar TenantAwareJwtDecoder** para suporte a múltiplos tenants dinâmicos
2. **Configurar Authorization Code Flow** no frontend (substituir Password Grant)
3. **Implementar Refresh Token rotation** para maior segurança
4. **Adicionar observabilidade de autenticação** (métricas de login/logout/token validation)
5. **Integrar com Rate Limiting por usuário** (Resilience4j)
6. **Documentar fluxos OAuth2 no Swagger** (PKCE para SPAs)

## Referências

- [Keycloak Documentation](https://www.keycloak.org/documentation)
- [Spring Security OAuth2 Resource Server](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/index.html)
- [Testcontainers Keycloak](https://github.com/dasniko/testcontainers-keycloak)
- [RFC 6749 - OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)
- [RFC 7519 - JSON Web Token (JWT)](https://datatracker.ietf.org/doc/html/rfc7519)
- [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
- HIST-2026-014: Planejamento da integração Keycloak

## Conclusão

✅ Autenticação Keycloak OAuth2 Resource Server 100% implementada  
✅ Arquitetura hexagonal preservada (domain layer intocado)  
✅ Testes E2E completos com Testcontainers  
✅ Modelo Zero Trust implementado  
✅ Multi-tenancy via Realm-per-Tenant pronto  
✅ Infraestrutura Docker Compose para desenvolvimento local  

**Resultado**: Sistema pronto para autenticação em produção com Keycloak, mantendo todos os princípios arquiteturais e com cobertura de testes completa.
