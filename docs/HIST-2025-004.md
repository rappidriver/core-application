# HIST-2025-004: Implementar Ports e Interfaces

**Data**: 03/01/2026  
**Status**: DONE  
**Tipo**: Feature

## Descrição

Implementar as portas (ports) e interfaces da arquitetura hexagonal para estabelecer os contratos entre as camadas da aplicação. Esta história cria a base para a comunicação entre domain, application e infrastructure.

## Objetivos

1. Definir **Output Ports** (Repository interfaces)
2. Definir **Input Ports** (Use Case interfaces)
3. Implementar **JPA Entities** na camada de infraestrutura
4. Implementar **Repository Adapters** (implementação das output ports)
5. Implementar **Mappers** (Domain ↔ JPA)
6. Implementar **Use Cases** básicos (CRUD)
7. Criar testes unitários e de integração

## Estrutura de Pacotes

```
src/main/java/com/rappidrive/
├── application/
│   ├── ports/
│   │   ├── input/           # Use Case interfaces
│   │   │   ├── driver/
│   │   │   ├── passenger/
│   │   │   └── trip/
│   │   └── output/          # Repository interfaces
│   │       ├── DriverRepositoryPort.java
│   │       ├── PassengerRepositoryPort.java
│   │       └── TripRepositoryPort.java
│   └── usecases/            # Use Case implementations
│       ├── driver/
│       ├── passenger/
│       └── trip/
├── infrastructure/
│   ├── persistence/
│   │   ├── entities/        # JPA Entities
│   │   ├── repositories/    # Spring Data JPA interfaces
│   │   ├── adapters/        # Repository Adapters
│   │   └── mappers/         # Domain ↔ JPA Mappers
│   └── config/              # Spring Configuration
└── domain/                  # Já implementado (HIST-2025-003)
```

## Output Ports (Repository Interfaces)

### DriverRepositoryPort
- `save(Driver driver): Driver`
- `findById(UUID id): Optional<Driver>`
- `findByTenantId(UUID tenantId): List<Driver>`
- `findByEmail(Email email): Optional<Driver>`
- `findByCpf(CPF cpf): Optional<Driver>`
- `findByStatus(DriverStatus status, UUID tenantId): List<Driver>`
- `existsByEmail(Email email): boolean`
- `existsByCpf(CPF cpf): boolean`
- `delete(UUID id): void`

### PassengerRepositoryPort
- `save(Passenger passenger): Passenger`
- `findById(UUID id): Optional<Passenger>`
- `findByTenantId(UUID tenantId): List<Passenger>`
- `findByEmail(Email email): Optional<Passenger>`
- `findByStatus(PassengerStatus status, UUID tenantId): List<Passenger>`
- `existsByEmail(Email email): boolean`
- `delete(UUID id): void`

### TripRepositoryPort
- `save(Trip trip): Trip`
- `findById(UUID id): Optional<Trip>`
- `findByTenantId(UUID tenantId): List<Trip>`
- `findByDriver(UUID driverId): List<Trip>`
- `findByPassenger(UUID passengerId): List<Trip>`
- `findByStatus(TripStatus status, UUID tenantId): List<Trip>`
- `findActiveTrips(UUID tenantId): List<Trip>`
- `delete(UUID id): void`

## Input Ports (Use Case Interfaces)

### Driver Use Cases
- **CreateDriverInputPort**: Criar novo motorista
- **GetDriverInputPort**: Buscar motorista por ID
- **UpdateDriverInputPort**: Atualizar dados do motorista
- **ActivateDriverInputPort**: Ativar motorista
- **DeactivateDriverInputPort**: Desativar motorista
- **BlockDriverInputPort**: Bloquear motorista
- **UpdateDriverLocationInputPort**: Atualizar localização

### Passenger Use Cases
- **CreatePassengerInputPort**: Criar novo passageiro
- **GetPassengerInputPort**: Buscar passageiro por ID
- **UpdatePassengerInputPort**: Atualizar dados do passageiro
- **ActivatePassengerInputPort**: Ativar passageiro
- **DeactivatePassengerInputPort**: Desativar passageiro
- **BlockPassengerInputPort**: Bloquear passageiro

### Trip Use Cases
- **CreateTripInputPort**: Criar nova corrida
- **AssignDriverToTripInputPort**: Atribuir motorista à corrida
- **StartTripInputPort**: Iniciar corrida
- **CompleteTripInputPort**: Completar corrida
- **CancelTripInputPort**: Cancelar corrida
- **GetTripInputPort**: Buscar corrida por ID
- **FindAvailableDriversInputPort**: Buscar motoristas disponíveis

## JPA Entities

Criar entidades JPA espelhando as domain entities:
- `DriverJpaEntity`
- `PassengerJpaEntity`
- `TripJpaEntity`

**Características:**
- Anotações JPA: `@Entity`, `@Table`, `@Column`, etc.
- Conversores customizados para Value Objects (Email, CPF, Phone, etc.)
- Relacionamentos: `@ManyToOne`, `@OneToMany` quando necessário
- Atributo `tenant_id` em todas as entidades (multi-tenancy)

## Mappers

Utilizar **MapStruct** para converter entre Domain e JPA entities:
- `DriverMapper`
- `PassengerMapper`
- `TripMapper`

**Métodos:**
- `toDomain(JpaEntity): DomainEntity`
- `toJpaEntity(DomainEntity): JpaEntity`

## Testes

### Testes Unitários
- Mappers (conversão Domain ↔ JPA)
- Use Cases (com mocks dos repositories)

### Testes de Integração
- Repository Adapters (com Testcontainers PostgreSQL)
- Verificar persistência, queries, constraints

### Cobertura Esperada
- Mappers: 100%
- Use Cases: > 90%
- Repository Adapters: > 80%

## Critérios de Aceitação

- [x] Todos os Output Ports definidos
- [x] Todos os Input Ports definidos
- [x] JPA Entities implementadas com anotações corretas
- [x] Repository Adapters implementados
- [x] Mappers implementados com MapStruct
- [x] Use Cases implementados
- [x] Testes unitários passando (> 90% cobertura)
- [x] Testes de integração passando (com Testcontainers)
- [x] ArchUnit validando dependências hexagonais
- [x] Nenhuma dependência de framework no domain layer
- [x] Código compilando sem warnings críticos

## Implementação Realizada

### Output Ports (3)
- DriverRepositoryPort
- PassengerRepositoryPort
- TripRepositoryPort

### Input Ports (11)
- CreateDriverInputPort, GetDriverInputPort, ActivateDriverInputPort, UpdateDriverLocationInputPort
- CreatePassengerInputPort, GetPassengerInputPort
- CreateTripInputPort, GetTripInputPort, AssignDriverToTripInputPort, StartTripInputPort, CompleteTripInputPort

### JPA Entities (3)
- DriverJpaEntity, PassengerJpaEntity, TripJpaEntity
- 7 JPA Converters para value objects

### Repository Adapters (3)
- JpaDriverRepositoryAdapter, JpaPassengerRepositoryAdapter, JpaTripRepositoryAdapter

### Mappers (3)
- DriverMapper, PassengerMapper, TripMapper (mapeamento manual para entidades imutáveis)

### Use Cases (11)
- Plain Java classes sem anotações Spring
- UseCaseConfiguration para injeção de dependências

### Database
- Migration V2 com tabelas drivers, passengers, trips
- Reconstruction constructors para persistência
- DriverStatus.BUSY adicionado

### Testes
- 236 testes passando (100%)
- Testes de arquitetura validando hexagonal architecture

## Notas Técnicas

- **Multi-tenancy**: Todas as queries devem filtrar por `tenant_id`
- **Transações**: Gerenciadas pela camada de infraestrutura
- **Exceções**: Converter exceções de infraestrutura em exceções de domínio
- **Imutabilidade**: Records para Commands/DTOs
- **Validações**: Input Ports devem validar comandos antes de executar
- **Mappers**: Mapeamento manual devido a entidades imutáveis

## Dependências

- HIST-2025-003 (Domain Entities) ✅

## Próximos Passos

- HIST-2025-005: Implementar REST Controllers (Presentation Layer)
- HIST-2025-006: Implementar autenticação e autorização
