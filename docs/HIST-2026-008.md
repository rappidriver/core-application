# HIST-2026-008: Database Connection Pool Monitoring

**Data:** 07/01/2026  
**Status:** EM ANDAMENTO  
**Tipo:** Otimização de Infraestrutura

## Contexto

Com Virtual Threads (HIST-2026-005), Parallel Execution (HIST-2026-006) e PostGIS queries otimizadas (HIST-2026-007), o sistema agora pode processar múltiplas requisições concorrentes eficientemente. Porém, o connection pool do HikariCP pode se tornar um gargalo se não estiver configurado adequadamente para alta concorrência.

## Objetivo

Implementar monitoramento e configuração otimizada do HikariCP para suportar carga concorrente com Virtual Threads, garantindo que o pool de conexões não seja um bottleneck.

## Escopo

### Funcionalidades
1. **Configuração HikariCP Otimizada**
   - Ajustar `maximumPoolSize` para concorrência com virtual threads
   - Configurar `minimumIdle` para evitar cold starts
   - Ajustar `connectionTimeout` e `idleTimeout`
   - Configurar `maxLifetime` para evitar stale connections

2. **Health Check Endpoint**
   - Endpoint `/actuator/health/db` com status do pool
   - Métricas: active connections, idle connections, waiting threads

3. **Logging de Pool Events**
   - Log quando pool atinge 80% da capacidade
   - Log de connection leaks (timeout)
   - Log de slow connection acquisition (>500ms)

4. **Testes de Carga**
   - Teste com 100 requisições concorrentes
   - Validar que pool não é bottleneck
   - Medir tempo de aquisição de conexão

## Critérios de Aceitação

- [ ] HikariCP configurado com pool size adequado para virtual threads
- [ ] Health check endpoint retorna métricas do pool
- [ ] Logs informativos sobre estado do pool
- [ ] Teste de carga com 100 requisições concorrentes passa
- [ ] Tempo de aquisição de conexão <50ms no percentil 95

## Implementação Técnica

### 1. Configuração HikariCP (application-dev.yml)
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 50  # Maior que padrão (10) para suportar virtual threads
      minimum-idle: 10       # Mantém conexões prontas
      connection-timeout: 5000
      idle-timeout: 300000   # 5 minutos
      max-lifetime: 1800000  # 30 minutos
      leak-detection-threshold: 60000  # Detecta leaks após 60s
      register-mbeans: true  # Habilita JMX para monitoring
```

### 2. Pool Monitoring Service
```java
@Service
@Slf4j
public class ConnectionPoolMonitor {
    private final HikariDataSource dataSource;
    
    @Scheduled(fixedRate = 30000) // A cada 30s
    public void logPoolMetrics() {
        HikariPoolMXBean pool = dataSource.getHikariPoolMXBean();
        int active = pool.getActiveConnections();
        int idle = pool.getIdleConnections();
        int total = pool.getTotalConnections();
        int waiting = pool.getThreadsAwaitingConnection();
        
        log.debug("HikariCP Pool: active={}, idle={}, total={}, waiting={}", 
                  active, idle, total, waiting);
        
        double utilization = (double) active / pool.getMaximumPoolSize();
        if (utilization > 0.8) {
            log.warn("Connection pool at {}% capacity! Consider increasing pool size.", 
                     (int)(utilization * 100));
        }
    }
}
```

### 3. Health Check Indicator
```java
@Component
public class DatabasePoolHealthIndicator implements HealthIndicator {
    private final HikariDataSource dataSource;
    
    @Override
    public Health health() {
        HikariPoolMXBean pool = dataSource.getHikariPoolMXBean();
        
        return Health.up()
            .withDetail("active", pool.getActiveConnections())
            .withDetail("idle", pool.getIdleConnections())
            .withDetail("total", pool.getTotalConnections())
            .withDetail("waiting", pool.getThreadsAwaitingConnection())
            .withDetail("max", dataSource.getMaximumPoolSize())
            .build();
    }
}
```

### 4. Load Test
```java
@SpringBootTest
class ConnectionPoolLoadTest {
    
    @Test
    void shouldHandleConcurrentRequests() {
        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
        
        List<CompletableFuture<Void>> futures = IntStream.range(0, 100)
            .mapToObj(i -> CompletableFuture.runAsync(() -> {
                // Simula query que leva 100ms
                driverRepository.findAll();
            }, executor))
            .toList();
            
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .join();
            
        // Valida que todas as 100 requisições foram bem-sucedidas
        assertThat(futures).allMatch(f -> !f.isCompletedExceptionally());
    }
}
```

## Stack Técnica

- **HikariCP**: Connection pool de alta performance
- **Spring Boot Actuator**: Health checks e métricas
- **Micrometer**: Métricas de observabilidade
- **Virtual Threads**: Concorrência eficiente

## Validação

### Testes
- [ ] Unit tests para ConnectionPoolMonitor
- [ ] Integration test para health check endpoint
- [ ] Load test com 100 requisições concorrentes
- [ ] Validar logs de warning quando pool >80%

### Performance
- Connection acquisition time <50ms (p95)
- Pool não deve ser bottleneck em carga concorrente
- Sem connection leaks detectados

## Riscos e Mitigações

**Risco**: Pool muito grande consome muitas conexões do PostgreSQL  
**Mitigação**: PostgreSQL configurado com `max_connections = 200`

**Risco**: Virtual threads podem criar milhares de threads esperando conexão  
**Mitigação**: Configurar `connection-timeout` para falhar rápido

## Próximos Passos Após Esta História

- HIST-2026-009: Query Result Caching (Redis)
- HIST-2026-010: Rate Limiting para APIs
- Features de negócio: Payment processing, Notifications

## Referências

- HikariCP Configuration: https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby
- Virtual Threads Best Practices: https://openjdk.org/jeps/444
- Spring Boot Actuator: https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html
